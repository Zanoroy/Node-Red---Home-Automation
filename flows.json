[
    {
        "id": "797d03fafe67193c",
        "type": "tab",
        "label": "Solar Info",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b8e1f2c3d4a5b6c7",
        "type": "tab",
        "label": "Hubitat Dashboard",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c9f1a2b3d4e5f6g7",
        "type": "tab",
        "label": "BOM Weather",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "google_weather_tab",
        "type": "tab",
        "label": "Google Weather API",
        "disabled": false,
        "info": "Google Weather API integration for Banksia Park, SA\nCollects current conditions and 10-day forecast\nStores data in SQLite database",
        "env": []
    },
    {
        "id": "uibuilder_dashboard_tab",
        "type": "tab",
        "label": "UIBuilder Dashboard",
        "disabled": false,
        "info": "UIBuilder-based Home Automation Dashboard\nIntegrates: Solar widget, Lights, Battery, Weather"
    },
    {
        "id": "d4045e31a39c5762",
        "type": "mqtt-broker",
        "name": "",
        "broker": "172.17.254.10",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "s9f8e7d6c5b4a3b2",
        "type": "sqlitedb",
        "db": "/root/.node-red/power_history.db",
        "mode": "RWC"
    },
    {
        "id": "gw_db_config",
        "type": "sqlitedb",
        "db": "/root/.node-red/google_weather.db",
        "mode": "RWC"
    },
    {
        "id": "a7dcb760939c0509",
        "type": "mqtt in",
        "z": "797d03fafe67193c",
        "name": "MQTT - Energy Topic",
        "topic": "energy/growatt",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "d4045e31a39c5762",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 140,
        "wires": [
            [
                "9d504389e63c252b",
                "f7a94d266b716497"
            ]
        ]
    },
    {
        "id": "9d504389e63c252b",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Battery State",
        "func": "// Extract values\nlet payload = msg.payload;\nlet SOC = payload.values.SOC;\nlet p1charge1 = payload.values.p1charge1;\nlet pdischarge1 = payload.values.pdischarge1;\n\n// Determine battery state\nlet state = \"idle\";\nif (pdischarge1 > 0) state = \"discharging\";\nelse if (p1charge1 > 0) state = \"charging\";\n\n// Output\nconst response = {\n    SOC: SOC,\n    state: state,\n    time: payload.time\n};\n\n// Store in global context for HTTP requests\nglobal.set('batteryData', response);\n\nreturn response;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "40b109e65a39f680",
        "type": "template",
        "z": "797d03fafe67193c",
        "name": "Battery Display Template",
        "field": "payload",
        "fieldType": "msg",
        "format": "html",
        "syntax": "mustache",
        "template": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <title>Battery Status Monitor</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n    <style>\n        /* Reset and base styles */\n        * {\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n            background: linear-gradient(135deg, #1a1a2e, #16213e);\n            color: white;\n            margin: 0;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            overflow-x: hidden;\n        }\n        \n        .battery-container {\n            text-align: center;\n            background: rgba(45, 45, 45, 0.95);\n            padding: clamp(20px, 5vw, 40px);\n            border-radius: 20px;\n            box-shadow: 0 15px 35px rgba(0,0,0,0.6);\n            backdrop-filter: blur(10px);\n            border: 1px solid rgba(255,255,255,0.1);\n            width: 100%;\n            max-width: 200px;\n        }\n        \n        .battery-wrapper {\n            position: relative;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            margin: clamp(15px, 4vw, 30px) 0;\n        }\n        \n        .battery-body {\n            position: relative;\n            width: clamp(150px, 40vw, 200px);\n            height: clamp(60px, 15vw, 80px);\n            border: clamp(3px, 1vw, 5px) solid #666;\n            border-radius: 12px;\n            background: #222;\n            overflow: hidden;\n            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .battery-terminal {\n            position: absolute;\n            right: calc(-1 * clamp(8px, 2vw, 12px));\n            top: 50%;\n            transform: translateY(-50%);\n            width: clamp(8px, 2vw, 12px);\n            height: clamp(30px, 8vw, 50px);\n            background: #666;\n            border-radius: 0 8px 8px 0;\n        }\n        \n        .battery-fill {\n            position: absolute;\n            top: 0;\n            left: 0;\n            height: 100%;\n            width: {{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}50{{/payload.SOC}}%;\n            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);\n            border-radius: 8px 0 0 8px;\n            background: var(--battery-color, #00ff00);\n        }\n        \n        .battery-percentage {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: clamp(18px, 5vw, 28px);\n            font-weight: 700;\n            color: white;\n            text-shadow: 2px 2px 8px rgba(0,0,0,0.9);\n            z-index: 10;\n        }\n        \n        .charging-symbol {\n            position: absolute;\n            top: clamp(8px, 2vw, 15px);\n            right: clamp(8px, 2vw, 15px);\n            font-size: clamp(16px, 4vw, 24px);\n            color: #ffff00;\n            font-weight: bold;\n            z-index: 10;\n            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);\n            display: none;\n        }\n        \n        /* State-based styling */\n        .battery-charging .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 20px rgba(0, 255, 65, 0.4);\n        }\n        \n        .battery-discharging .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 20px rgba(255, 68, 68, 0.4);\n        }\n        \n        .battery-idle .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 15px rgba(0, 255, 65, 0.2);\n        }\n        \n        /* Animations */\n        .flash {\n            animation: flash 1.5s ease-in-out infinite;\n        }\n        \n        .flashfont {\n            animation: flashfont 1.5s ease-in-out infinite;\n        }\n        \n        @keyframes flash {\n            0%, 60% { opacity: 1; transform: scale(1); }\n            61%, 100% { opacity: 0.4; transform: scale(1.05); }\n        }\n        \n        @keyframes flashfont {\n            0%, 70% { opacity: 1; }\n            71%, 100% { opacity: 0.5; }\n        }\n        \n        /* Typography */\n        h2 {\n            margin: 0 0 clamp(20px, 5vw, 30px) 0;\n            color: #fff;\n            font-size: clamp(20px, 5vw, 28px);\n            font-weight: 600;\n        }\n        \n        .status-text {\n            font-size: clamp(16px, 4vw, 20px);\n            font-weight: 600;\n            margin: clamp(15px, 4vw, 20px) 0 clamp(8px, 2vw, 10px) 0;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n        }\n        \n        .timestamp {\n            font-size: clamp(12px, 3vw, 14px);\n            color: #aaa;\n            margin-top: clamp(10px, 3vw, 15px);\n            opacity: 0.8;\n        }\n        \n        .error-message {\n            color: #ff6b6b;\n            font-size: clamp(14px, 3.5vw, 16px);\n            margin: 10px 0;\n            padding: 10px;\n            background: rgba(255, 107, 107, 0.1);\n            border-radius: 8px;\n            border: 1px solid rgba(255, 107, 107, 0.3);\n        }\n        \n        /* Responsive breakpoints */\n        @media (max-width: 480px) {\n            body { padding: 15px; }\n            .battery-container { padding: 20px 15px; }\n        }\n        \n        @media (max-width: 320px) {\n            body { padding: 10px; }\n            .battery-container { padding: 15px 10px; }\n        }\n        \n        @media (min-width: 1200px) {\n            .battery-container { max-width: 200px; }\n        }\n        \n        /* High DPI display support */\n        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {\n            .battery-body { border-width: 4px; }\n        }\n        \n        /* Reduced motion support */\n        @media (prefers-reduced-motion: reduce) {\n            .battery-fill { transition: width 0.3s ease; }\n            .flash, .flashfont { animation: none; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"battery-container\">\n        <h2>Battery Status</h2>\n        \n        <div class=\"battery-wrapper\">\n            <div class=\"battery-body battery-{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}idle{{/payload.state}}\" id=\"batteryIcon\">\n                <div class=\"battery-fill\" id=\"batteryFill\"></div>\n                <div class=\"battery-percentage\">{{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}--{{/payload.SOC}}%</div>\n                <div class=\"charging-symbol flash\" id=\"chargingSymbol\">⚡</div>\n            </div>\n            <div class=\"battery-terminal\"></div>\n        </div>\n        \n        <div class=\"status-text\">\n            <span id=\"stateFont\">{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}Unknown{{/payload.state}}</span>\n        </div>\n        \n        <div class=\"timestamp\">\n            Last Update: <span id=\"lastUpdate\">{{#timestamp}}{{timestamp}}{{/timestamp}}{{^timestamp}}{{#payload.time}}{{payload.time}}{{/payload.time}}{{^payload.time}}Unknown{{/payload.time}}{{/timestamp}}</span>\n        </div>\n    </div>\n\n    <script>\n        // Robust error handling and data validation\n        try {\n            const state = '{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}idle{{/payload.state}}'.toLowerCase();\n            const socValue = {{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}50{{/payload.SOC}};\n            \n            const chargingSymbol = document.getElementById('chargingSymbol');\n            const batteryIcon = document.getElementById('batteryIcon');\n            const stateFont = document.getElementById('stateFont');\n            const batteryFill = document.getElementById('batteryFill');\n            \n            // Validate SOC value\n            const validSOC = Math.max(0, Math.min(100, socValue || 0));\n            \n            // Set battery color based on SOC level\n            let batteryColor;\n            if (validSOC < 20) batteryColor = '#ff4444';\n            else if (validSOC < 40) batteryColor = '#ff9100';\n            else if (validSOC < 60) batteryColor = '#fff200';\n            else if (validSOC < 80) batteryColor = '#d7fc03';\n            else batteryColor = '#00ff00';\n            \n            document.documentElement.style.setProperty('--battery-color', batteryColor);\n            \n            // Handle different states\n            if (state === 'charging') {\n                stateFont.style.color = '#00ff00';\n                chargingSymbol.style.display = 'block';\n                batteryIcon.classList.add('battery-charging');\n                stateFont.classList.add('flashfont');\n            } else if (state === 'discharging') {\n                stateFont.style.color = '#ff6b6b';\n                batteryIcon.classList.add('battery-discharging');\n                stateFont.classList.add('flashfont');\n            } else {\n                stateFont.style.color = '#ffffff';\n                batteryIcon.classList.add('battery-idle');\n            }\n            \n            // Format timestamp if available\n            const lastUpdate = document.getElementById('lastUpdate');\n            const timeStr = lastUpdate.textContent;\n            if (timeStr && timeStr !== 'Unknown') {\n                try {\n                    const date = new Date(timeStr);\n                    if (!isNaN(date.getTime())) {\n                        lastUpdate.textContent = date.toLocaleString();\n                    }\n                } catch (e) {\n                    console.warn('Could not parse timestamp:', timeStr);\n                }\n            }\n            \n            // Smart refresh with exponential backoff on errors\n            let refreshAttempts = 0;\n            const maxAttempts = 5;\n            \n            function scheduleRefresh() {\n                const baseDelay = 15000; // 15 seconds base\n                const delay = refreshAttempts > 0 ? baseDelay * Math.pow(2, refreshAttempts) : baseDelay;\n                const maxDelay = 60000; // Max 1 minute\n                \n                setTimeout(() => {\n                    try {\n                        window.location.reload();\n                    } catch (e) {\n                        refreshAttempts = Math.min(refreshAttempts + 1, maxAttempts);\n                        if (refreshAttempts < maxAttempts) {\n                            scheduleRefresh();\n                        }\n                    }\n                }, Math.min(delay, maxDelay));\n            }\n            \n            scheduleRefresh();\n            \n        } catch (error) {\n            console.error('Battery display error:', error);\n            // Show error message to user\n            const container = document.querySelector('.battery-container');\n            if (container) {\n                const errorDiv = document.createElement('div');\n                errorDiv.className = 'error-message';\n                errorDiv.textContent = 'Display error: Please refresh the page';\n                container.appendChild(errorDiv);\n            }\n        }\n    </script>\n</body>\n</html>",
        "output": "str",
        "x": 750,
        "y": 260,
        "wires": [
            [
                "f7f04a3f477ab654"
            ]
        ]
    },
    {
        "id": "3d2c230142bb2983",
        "type": "http in",
        "z": "797d03fafe67193c",
        "name": "Battery Status Endpoint",
        "url": "/battery-status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 260,
        "wires": [
            [
                "466161e1adb6b7c7"
            ]
        ]
    },
    {
        "id": "466161e1adb6b7c7",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Get Battery Data for HTTP",
        "func": "// Get the latest battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'Idle',\n    time: new Date().toISOString()\n};\nconst timestamp = batteryData.time || new Date().toISOString();\n\nmsg.payload = batteryData;\nmsg.timestamp = timestamp;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 260,
        "wires": [
            [
                "40b109e65a39f680"
            ]
        ]
    },
    {
        "id": "f7f04a3f477ab654",
        "type": "http response",
        "z": "797d03fafe67193c",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "text/html"
        },
        "x": 1020,
        "y": 260,
        "wires": []
    },
    {
        "id": "f7a94d266b716497",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Power Data",
        "func": "// Extract values\nlet payload = msg.payload;\n\nconst response = {\n    pvpowerin:   payload.values.pvpowerin,            // power being produced\n    pv1watt:     payload.values.pv1watt,              // power being produced\n    pactogridr:  payload.values.pactogridr,           // Power exported to grid\n    pactouserr:  payload.values.pactouserr,           // Power being drawn from grid\n    p1charge1:   payload.values.p1charge1,            // battery charging\n    pdischarge1: payload.values.pdischarge1,          // battery discharging \n    timestamp: new Date(payload.time).toISOString() // last time date was received from the invertor\n};\n\n// Store in global context for HTTP requests\nglobal.set('powerGraphData', response);\n\nreturn response;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "// const response = {\n//     pv1watt:     0,     // power being produced\n//     pactogridr:  0,  // Power exported to grid\n//     pactouserr:  0,  // Power being drawn from grid\n//     p1charge1:   0,   // battery charging\n//     pdischarge1: 0, // battery discharging \n//     lastupdated: '2025-01-01 00:00:00' // last time date was received from the invertor\n// };\n\n// // Store in global context for HTTP requests\n// global.set('powerGraphData', response);\n\n// return response;",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 180,
        "wires": [
            [
                "s1a2b3c4d5e6f7g8"
            ]
        ]
    },
    {
        "id": "s1a2b3c4d5e6f7g8",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Prepare SQLite Insert",
        "func": "// Prepare data for SQLite insertion\nconst powerData = msg;\n\n// Use current timestamp if not provided\nconst timestamp = powerData.timestamp || new Date().toISOString();\n\n// Convert to kilowatts for storage\nconst record = {\n    timestamp: timestamp,\n    pv_production: (powerData.pvpowerin || 0),\n    grid_export: (powerData.pactogridr || 0),\n    grid_import: (powerData.pactouserr || 0),\n    battery_charge: (powerData.p1charge1 || 0),\n    battery_discharge: (powerData.pdischarge1 || 0)\n};\n\n// Create complete SQL statement with quoted values\nmsg.topic = `INSERT OR REPLACE INTO power_history \n    (timestamp, pv_production, grid_export, grid_import, battery_charge, battery_discharge) \n    VALUES ('${record.timestamp}', ${record.pv_production}, ${record.grid_export}, ${record.grid_import}, ${record.battery_charge}, ${record.battery_discharge})`;\n\n// Set empty payload for direct SQL execution\nmsg.payload = [];\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Storing: ${record.timestamp}`});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            [
                "s2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "s2a3b4c5d6e7f8g9",
        "type": "sqlite",
        "z": "797d03fafe67193c",
        "mydb": "s9f8e7d6c5b4a3b2",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Store Power Data",
        "x": 970,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "s3a4b5c6d7e8f9g0",
        "type": "debug",
        "z": "797d03fafe67193c",
        "name": "SQLite Storage Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 180,
        "wires": []
    },
    {
        "id": "s4a5b6c7d8e9f0g1",
        "type": "inject",
        "z": "797d03fafe67193c",
        "name": "Initialize Database",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 2,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 40,
        "wires": [
            [
                "s5a6b7c8d9e0f1g2"
            ]
        ]
    },
    {
        "id": "s5a6b7c8d9e0f1g2",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Create Tables",
        "func": "// Create power_history table with proper schema\nmsg.topic = `CREATE TABLE IF NOT EXISTS power_history (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    timestamp TEXT UNIQUE NOT NULL,\n    pv_production REAL DEFAULT 0,\n    grid_export REAL DEFAULT 0,\n    grid_import REAL DEFAULT 0,\n    battery_charge REAL DEFAULT 0,\n    battery_discharge REAL DEFAULT 0,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n)`;\n\nmsg.payload = [];\n\nnode.status({fill:\"green\",shape:\"dot\",text:\"Creating tables...\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 40,
        "wires": [
            [
                "s6a7b8c9d0e1f2g3"
            ]
        ]
    },
    {
        "id": "s6a7b8c9d0e1f2g3",
        "type": "sqlite",
        "z": "797d03fafe67193c",
        "mydb": "s9f8e7d6c5b4a3b2",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Create DB Schema",
        "x": 580,
        "y": 40,
        "wires": [
            [
                "s7a8b9c0d1e2f3g4"
            ]
        ]
    },
    {
        "id": "s7a8b9c0d1e2f3g4",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Create Index",
        "func": "// Create index on timestamp for better query performance\nmsg.topic = `CREATE INDEX IF NOT EXISTS idx_power_timestamp ON power_history(timestamp)`;\nmsg.payload = [];\n\nnode.status({fill:\"green\",shape:\"dot\",text:\"Creating indexes...\"});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 40,
        "wires": [
            [
                "s8a9b0c1d2e3f4g5"
            ]
        ]
    },
    {
        "id": "s8a9b0c1d2e3f4g5",
        "type": "sqlite",
        "z": "797d03fafe67193c",
        "mydb": "s9f8e7d6c5b4a3b2",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Create Index",
        "x": 970,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "s0a1b2c3d4e5f6g7",
        "type": "debug",
        "z": "797d03fafe67193c",
        "name": "DB Init Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1160,
        "y": 40,
        "wires": []
    },
    {
        "id": "hist001",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Historical Data API",
        "url": "/historical-power-data",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 500,
        "wires": [
            [
                "hist002"
            ]
        ]
    },
    {
        "id": "hist002",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Prepare Historical Query",
        "func": "// Parse query parameters for time range\nconst query = msg.req.query || {};\nconst hours = parseInt(query.hours) || 24; // Default to 24 hours\nconst limit = parseInt(query.limit) || 1000; // Default limit\n\n// Calculate timestamp for time range\nconst startTime = new Date();\nstartTime.setHours(startTime.getHours() - hours);\nconst startTimeStr = startTime.toISOString();\n\n// SQL query for historical data\nmsg.topic = `SELECT \n    datetime(timestamp) as timestamp,\n    pv_production,\n    grid_export,\n    grid_import,\n    battery_charge,\n    battery_discharge\nFROM power_history \nWHERE timestamp >= '${startTimeStr}'\nORDER BY timestamp DESC\nLIMIT ${limit}`;\n\nmsg.payload = [];\n\n// Store original request for response formatting\nmsg.originalReq = {\n    hours: hours,\n    limit: limit\n};\n\nnode.status({fill:\"blue\",shape:\"dot\",text:`Query: ${hours}h, limit: ${limit}`});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 500,
        "wires": [
            [
                "hist003"
            ]
        ]
    },
    {
        "id": "hist003",
        "type": "sqlite",
        "z": "b8e1f2c3d4a5b6c7",
        "mydb": "s9f8e7d6c5b4a3b2",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Query Historical Data",
        "x": 720,
        "y": 500,
        "wires": [
            [
                "hist004"
            ]
        ]
    },
    {
        "id": "hist004",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Format Historical Response",
        "func": "// Format the historical data response\nconst data = msg.payload || [];\nconst meta = msg.originalReq || {};\n\n// Convert to kilowatts and format for Chart.js\nconst formattedData = data.map(row => ({\n    timestamp: row.timestamp,\n    pv_production: (row.pv_production || 0),\n    grid_export: (row.grid_export || 0), \n    grid_import: (row.grid_import || 0),\n    battery_charge: (row.battery_charge || 0),\n    battery_discharge: (row.battery_discharge || 0)\n}));\n\n// Prepare Chart.js format\nconst chartData = {\n    labels: formattedData.map(d => {\n        const date = new Date(d.timestamp);\n        return date.toLocaleTimeString('en-AU', {\n            hour: '2-digit',\n            minute: '2-digit',\n            day: '2-digit',\n            month: 'short'\n        });\n    }),\n    datasets: [\n        {\n            label: 'PV Production',\n            data: formattedData.map(d => d.pv_production),\n            borderColor: 'rgb(255, 193, 7)',\n            backgroundColor: 'rgba(255, 193, 7, 0.1)',\n            fill: true\n        },\n        {\n            label: 'Grid Export',\n            data: formattedData.map(d => d.grid_export),\n            borderColor: 'rgb(40, 167, 69)',\n            backgroundColor: 'rgba(40, 167, 69, 0.1)',\n            fill: true\n        },\n        {\n            label: 'Grid Import',\n            data: formattedData.map(d => d.grid_import),\n            borderColor: 'rgb(220, 53, 69)',\n            backgroundColor: 'rgba(220, 53, 69, 0.1)',\n            fill: true\n        },\n        {\n            label: 'Battery Charge',\n            data: formattedData.map(d => d.battery_charge),\n            borderColor: 'rgb(23, 162, 184)',\n            backgroundColor: 'rgba(23, 162, 184, 0.1)',\n            fill: true\n        },\n        {\n            label: 'Battery Discharge',\n            data: formattedData.map(d => d.battery_discharge),\n            borderColor: 'rgb(108, 117, 125)',\n            backgroundColor: 'rgba(108, 117, 125, 0.1)',\n            fill: true\n        }\n    ]\n};\n\n// Response with metadata\nmsg.payload = {\n    success: true,\n    data: chartData,\n    raw: formattedData,\n    meta: {\n        count: formattedData.length,\n        hours: meta.hours,\n        limit: meta.limit,\n        generated: new Date().toISOString()\n    }\n};\n\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'Cache-Control': 'no-cache'\n};\n\nnode.status({fill:\"green\",shape:\"dot\",text:`Returned ${formattedData.length} records`});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 500,
        "wires": [
            [
                "hist005"
            ]
        ]
    },
    {
        "id": "hist005",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Historical Data Response",
        "statusCode": "",
        "headers": {},
        "x": 1250,
        "y": 500,
        "wires": []
    },
    {
        "id": "h1a2b3c4d5e6f7g8",
        "type": "inject",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Fetch Devices on Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 280,
        "y": 120,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "h2a3b4c5d6e7f8g9",
        "type": "http request",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Get All Hubitat Devices",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://172.17.98.214/apps/api/93/devices/all?access_token=c978917f-7089-4041-937f-414a0bb2ab6d",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 540,
        "y": 120,
        "wires": [
            [
                "h3a4b5c6d7e8f9g0"
            ]
        ]
    },
    {
        "id": "h5a6b7c8d9e0f1g2",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Dashboard Endpoint",
        "url": "/hubitat-dashboard",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 340,
        "wires": [
            [
                "h6a7b8c9d0e1f2g3"
            ]
        ]
    },
    {
        "id": "h6a7b8c9d0e1f2g3",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Prepare Dashboard Data",
        "func": "// Get the light devices from global context\nconst lightDevices = global.get('hubitatLights') || [];\n\n// Get the battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'unknown',\n    time: new Date().toISOString()\n};\n\n// If no devices found, return empty array but still include battery\nif (lightDevices.length === 0) {\n    msg.payload = {\n        lights: [],\n        battery: batteryData,\n        timestamp: new Date().toISOString(),\n        status: 'No light devices found'\n    };\n    return msg;\n}\n\n// Process devices to get current status\nconst processedLights = lightDevices.map(device => {\n    // Determine current state based on device attributes\n    let isOn = false;\n    if (device.attributes) {\n        // Handle both array and object formats\n        if (Array.isArray(device.attributes)) {\n            const switchAttr = device.attributes.find(attr => attr.name === 'switch');\n            isOn = switchAttr && switchAttr.currentValue === 'on';\n        } else if (device.attributes.switch) {\n            isOn = device.attributes.switch === 'on';\n        }\n    }\n    \n    return {\n        id: device.id,\n        name: device.label || device.name,\n        state: isOn ? 'on' : 'off',\n        type: device.type || 'Light'\n    };\n});\n\nmsg.payload = {\n    lights: processedLights,\n    battery: batteryData,\n    timestamp: new Date().toISOString(),\n    status: 'ok'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 340,
        "wires": [
            [
                "h7a8b9c0d1e2f3g4"
            ]
        ]
    },
    {
        "id": "h7a8b9c0d1e2f3g4",
        "type": "template",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Hubitat Dashboard Template",
        "field": "payload",
        "fieldType": "msg",
        "format": "html",
        "syntax": "mustache",
        "template": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Hubitat Smart Home Dashboard</title>\n    <link rel=\"stylesheet\" href=\"/public/hubitat-dashboard.css\">\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n    <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js\"></script>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <div class=\"endless-grid\" id=\"mainGrid\">\n            <div class=\"weather-grid\" id=\"weatherGrid\">\n                <div class=\"weather-tile\" id=\"weatherTile\">\n                    <div class=\"weather-icon-column\">\n                        <img id=\"weatherIcon\" class=\"weather-icon\" src=\"\" alt=\"Weather\" onerror=\"this.style.display='none'\">\n                    </div>\n                    <div class=\"weather-info-column\">\n                        <table class=\"weather-table\">\n                            <tr>\n                                <td class=\"weather-cell\">\n                                    <div class=\"weather-label\">Current</div>\n                                    <div class=\"weather-temp-large\" id=\"currentTemp\">--°C</div>\n                                </td>\n                                <td class=\"weather-cell\">\n                                    <div class=\"weather-label\">Feels like</div>\n                                    <div class=\"weather-temp-large\" id=\"feelsLikeTemp\">--°C</div>\n                                </td>\n                            </tr>\n                            <tr>\n                                <td class=\"weather-cell\">\n                                    <div class=\"weather-label\">Min</div>\n                                    <div class=\"weather-temp-large weather-temp-min\" id=\"minTemp\">--°C</div>\n                                </td>\n                                <td class=\"weather-cell\">\n                                    <div class=\"weather-label\">Max</div>\n                                    <div class=\"weather-temp-large weather-temp-max\" id=\"maxTemp\">--°C</div>\n                                </td>\n                            </tr>\n                            <tr>\n                                <td colspan=\"2\" class=\"weather-cell weather-description\">\n                                    <div id=\"weatherDescription\">Loading weather...</div>\n                                </td>\n                            </tr>\n                            <tr style=\"display: none;\">\n                                <td colspan=\"2\" class=\"weather-cell\">\n                                    <div id=\"chanceOfRain\">Chance of rain: --%</div>\n                                </td>\n                            </tr>\n                        </table>\n                    </div>\n                </div>\n            </div>\n            <div class=\"light-grid\" id=\"lightsGrid\">\n                {{#payload.lights}}\n                <div class=\"light-tile {{state}}\" data-device-id=\"{{id}}\" onclick=\"toggleLight({{id}}, '{{state}}')\">\n                    <div class=\"loading-spinner\"></div>\n                    <div class=\"light-bulb-container\">\n                        <i class=\"fas fa-lightbulb light-bulb\"></i>\n                    </div>\n                    <div class=\"light-label\">{{name}}</div>\n                </div>\n                {{/payload.lights}}\n                \n            </div>\n            <div class=\"solar-grid\" id=\"solarGrid\">\n                <!-- Battery Status Tile -->\n                <div class=\"battery-tile {{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}unknown{{/payload.battery.state}}\"\n                    id=\"batteryTile\">\n                    <div class=\"battery-wrapper\">\n                        <div class=\"battery-body\">\n                            <div class=\"battery-fill\" id=\"batteryFill\"></div>\n                            <div class=\"battery-percentage\">\n                                {{#payload.battery.SOC}}{{payload.battery.SOC}}{{/payload.battery.SOC}}{{^payload.battery.SOC}}--{{/payload.battery.SOC}}%\n                            </div>\n                            <div class=\"charging-symbol\" id=\"chargingSymbol\">⚡</div>\n                        </div>\n                        <div class=\"battery-terminal\"></div>\n                    </div>\n                    <div class=\"status-text\">\n                        <span id=\"stateFont\" style=\"color: #ffffff;\">{{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}Idle{{/payload.battery.state}}</span>\n                    </div>\n                    <div class=\"battery-label\">Battery Status</div>\n                </div>\n                <!-- Power Chart -->\n                <div class=\"power-chart-tile\">\n                    <div class=\"chart-header\">\n                        <h3>Energy Flow</h3>\n                        <div class=\"chart-controls\">\n                            <button class=\"time-range-btn active\" onclick=\"loadHistoricalData(1, this)\">1H</button>\n                            <button class=\"time-range-btn\" onclick=\"loadHistoricalData(6, this)\">6H</button>\n                            <button class=\"time-range-btn\" onclick=\"loadHistoricalData(24, this)\">24H</button>\n                            <button class=\"time-range-btn\" onclick=\"loadHistoricalData(168, this)\">7D</button>\n                            <button class=\"time-range-btn\" onclick=\"switchToLive(this)\">Live</button>\n                        </div>\n                        <div class=\"chart-legend\">\n                            <div class=\"legend-item\"><span class=\"legend-color pv-production\"></span>PV Production</div>\n                            <div class=\"legend-item\"><span class=\"legend-color grid-export\"></span>Grid Export</div>\n                            <div class=\"legend-item\"><span class=\"legend-color grid-import\"></span>Grid Import</div>\n                            <div class=\"legend-item\"><span class=\"legend-color battery-charge\"></span>Battery Charge</div>\n                            <div class=\"legend-item\"><span class=\"legend-color battery-discharge\"></span>Battery Discharge</div>\n                        </div>\n                    </div>\n                    <div class=\"chart-container\">\n                        <canvas id=\"powerChart\" width=\"800\" height=\"300\"></canvas>\n                    </div>\n                </div>\n            </div>\n            <div class=\"status-bar\">\n                <span id=\"statusText\" class=\"status-online\">Connected</span> | \n                Last Update: <span id=\"lastUpdate\">{{payload.timestamp}}</span>\n            </div>\n        </div>\n    </div>\n    <script>\n        let isPolling = true;\n        \n        // Format timestamp\n        function formatTimestamp(timestamp) {\n            return new Date(timestamp).toLocaleString();\n        }\n        \n        // Update last update timestamp\n        document.getElementById('lastUpdate').textContent = formatTimestamp('{{payload.timestamp}}');\n        \n        // Initialize battery display\n        initializeBattery();\n        \n        // Initialize weather display\n        initializeWeather();\n        \n        // Initialize power chart\n        initializePowerChart();\n        \n        function initializeBattery() {\n            try {\n                const batteryData = {\n                    state: '{{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}unknown{{/payload.battery.state}}',\n                    SOC: {{#payload.battery.SOC}}{{payload.battery.SOC}}{{/payload.battery.SOC}}{{^payload.battery.SOC}}0{{/payload.battery.SOC}}\n                };\n                \n                const chargingSymbol = document.getElementById('chargingSymbol');\n                const batteryTile = document.getElementById('batteryTile');\n                const batteryFill = document.getElementById('batteryFill');\n                const stateFont = document.getElementById('stateFont');\n\n                // Validate SOC value\n                const validSOC = Math.max(0, Math.min(100, batteryData.SOC || 0));\n                \n                // Set battery fill width\n                batteryFill.style.width = validSOC + '%';\n                \n                // Set battery color based on SOC level\n                let batteryColor;\n                if (validSOC < 20) batteryColor = '#ff4444';\n                else if (validSOC < 40) batteryColor = '#ff9100';\n                else if (validSOC < 60) batteryColor = '#fff200';\n                else if (validSOC < 80) batteryColor = '#d7fc03';\n                else batteryColor = '#00ff00';\n                \n                batteryFill.style.background = batteryColor;\n                \n                // Handle charging state\n                if (batteryData.state.toLowerCase() === 'charging') {\n                    chargingSymbol.style.display = 'block';\n                    chargingSymbol.classList.add('flash');\n                    batteryTile.classList.add('battery-charging');\n                    stateFont.style.color = '#00ff00';\n                    stateFont.classList.remove('flashfont');\n                    stateFont.innerHTML = \"charging\";\n                } else {\n                    chargingSymbol.style.display = 'none';\n                    chargingSymbol.classList.remove('flash');\n                    if (batteryData.state.toLowerCase() === 'discharging') {\n                        batteryTile.classList.add('battery-discharging');\n                        stateFont.style.color = '#ff6b6b';\n                        stateFont.classList.add('flashfont');\n                        stateFont.innerHTML = \"discharging\";\n                    } else {\n                        batteryTile.classList.add('battery-idle');\n                        stateFont.style.color = '#ffffff';\n                        stateFont.classList.remove('flashfont');\n                        stateFont.innerHTML = \"idle\";\n                    }\n                }\n            } catch (error) {\n                console.warn('Battery initialization error:', error);\n            }\n        }\n        \n        // Initialize weather display\n        function initializeWeather() {\n            fetchWeatherData();\n        }\n        \n        // Fetch weather data from API\n        async function fetchWeatherData() {\n            try {\n                const response = await fetch('/weather');\n                if (response.ok) {\n                    const weatherData = await response.json();\n                    updateWeatherDisplay(weatherData);\n                } else {\n                    console.warn('Weather data not available');\n                    updateWeatherDisplay(null);\n                }\n            } catch (error) {\n                console.error('Error fetching weather:', error);\n                updateWeatherDisplay(null);\n            }\n        }\n        \n        // Update weather display\n        function updateWeatherDisplay(weatherData) {\n            const weatherIcon = document.getElementById('weatherIcon');\n            const currentTemp = document.getElementById('currentTemp');\n            const feelsLikeTemp = document.getElementById('feelsLikeTemp');\n            const minTemp = document.getElementById('minTemp');\n            const maxTemp = document.getElementById('maxTemp');\n            const weatherDescription = document.getElementById('weatherDescription');\n            const chanceOfRain = document.getElementById('chanceOfRain');\n            \n            if (!weatherData || weatherData.error) {\n                // Show placeholder data\n                currentTemp.textContent = '--°C';\n                feelsLikeTemp.textContent = '--°C';\n                minTemp.textContent = '--°C';\n                maxTemp.textContent = '--°C';\n                weatherDescription.textContent = 'Weather data unavailable';\n                chanceOfRain.textContent = 'Chance of rain: --%';\n                weatherIcon.style.display = 'none';\n                return;\n            }\n            \n            // Update temperature displays\n            currentTemp.textContent = weatherData.temperature ? weatherData.temperature + '°C' : '--°C';\n            feelsLikeTemp.textContent = weatherData.apparent_temperature ? weatherData.apparent_temperature + '°C' : '--°C';\n            minTemp.textContent = weatherData.min_temperature ? weatherData.min_temperature + '°C' : '--°C';\n            maxTemp.textContent = weatherData.max_temperature ? weatherData.max_temperature + '°C' : '--°C';\n            \n            // Update weather description\n            if (weatherData.cloud_description) {\n                weatherDescription.textContent = weatherData.cloud_description;\n                \n                // Determine if it's day or night (simplified check)\n                const now = new Date();\n                const hour = now.getHours();\n                const isDayTime = hour >= 6 && hour < 18;\n                \n                // Set weather icon\n                let iconUrl = '';\n                if (weatherData.cloud_description.startsWith('Mostly ')) {\n                    iconUrl = isDayTime ? \n                        'http://reg.bom.gov.au/weather-services/images/symbols/large/partly-cloudy.png' :\n                        'http://reg.bom.gov.au/weather-services/images/symbols/large/partly-cloudy-night.png';\n                } else {\n                    // Convert description to lowercase and replace spaces with hyphens for URL\n                    const iconName = weatherData.cloud_description.toLowerCase().replace(/\\s+/g, '-');\n                    iconUrl = `http://reg.bom.gov.au/weather-services/images/symbols/large/${iconName}.png`;\n                }\n                \n                weatherIcon.src = iconUrl;\n                weatherIcon.style.display = 'block';\n                weatherIcon.onerror = function() {\n                    this.style.display = 'none';\n                };\n            } else {\n                weatherDescription.textContent = 'No description available';\n                weatherIcon.style.display = 'none';\n            }\n            \n            // Update chance of rain (placeholder for now)\n            chanceOfRain.textContent = 'Chance of rain: --%';\n        }\n        \n        // Power Chart Variables\n        let powerChart = null;\n        let isLiveMode = true;\n        let chartData = {\n            labels: [],\n            datasets: [\n                {\n                    label: 'PV Production',\n                    data: [],\n                    backgroundColor: 'rgba(255, 193, 7, 0.3)',\n                    borderColor: 'rgba(255, 193, 7, 1)',\n                    borderWidth: 2,\n                    fill: true,\n                    tension: 0.4\n                },\n                {\n                    label: 'Grid Export',\n                    data: [],\n                    backgroundColor: 'rgba(40, 167, 69, 0.3)',\n                    borderColor: 'rgba(40, 167, 69, 1)',\n                    borderWidth: 2,\n                    fill: true,\n                    tension: 0.4\n                },\n                {\n                    label: 'Grid Import',\n                    data: [],\n                    backgroundColor: 'rgba(220, 53, 69, 0.3)',\n                    borderColor: 'rgba(220, 53, 69, 1)',\n                    borderWidth: 2,\n                    fill: true,\n                    tension: 0.4\n                },\n                {\n                    label: 'Battery Charge',\n                    data: [],\n                    backgroundColor: 'rgba(0, 123, 255, 0.3)',\n                    borderColor: 'rgba(0, 123, 255, 1)',\n                    borderWidth: 2,\n                    fill: true,\n                    tension: 0.4\n                },\n                {\n                    label: 'Battery Discharge',\n                    data: [],\n                    backgroundColor: 'rgba(108, 117, 125, 0.3)',\n                    borderColor: 'rgba(108, 117, 125, 1)',\n                    borderWidth: 2,\n                    fill: true,\n                    tension: 0.4\n                }\n            ]\n        };\n        \n        // Initialize power chart\n        function initializePowerChart() {\n            const ctx = document.getElementById('powerChart').getContext('2d');\n            \n            powerChart = new Chart(ctx, {\n                type: 'line',\n                data: chartData,\n                options: {\n                    responsive: true,\n                    maintainAspectRatio: false,\n                    plugins: {\n                        legend: {\n                            display: false\n                        },\n                        tooltip: {\n                            mode: 'index',\n                            intersect: false,\n                            callbacks: {\n                                label: function(context) {\n                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' kW';\n                                }\n                            }\n                        }\n                    },\n                    scales: {\n                        x: {\n                            title: {\n                                display: true,\n                                text: 'Time',\n                                color: '#ffffff'\n                            },\n                            ticks: {\n                                color: '#ffffff',\n                                callback: function(value, index, values) {\n                                    const timestamp = this.getLabelForValue(value);\n                                    if (timestamp) {\n                                        const date = new Date(timestamp);\n                                        return date.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'});\n                                    }\n                                    return '';\n                                }\n                            },\n                            grid: {\n                                color: 'rgba(255, 255, 255, 0.1)'\n                            }\n                        },\n                        y: {\n                            beginAtZero: true,\n                            title: {\n                                display: true,\n                                text: 'Power (kW)',\n                                color: '#ffffff'\n                            },\n                            ticks: {\n                                color: '#ffffff'\n                            },\n                            grid: {\n                                color: 'rgba(255, 255, 255, 0.1)'\n                            }\n                        }\n                    },\n                    interaction: {\n                        intersect: false\n                    }\n                }\n            });\n            \n            // Initial data fetch\n            updateChartData();\n        }\n        \n        // Update chart with new data\n        async function updateChartData() {\n            try {\n                const response = await fetch('/power-graph-data');\n                if (response.ok) {\n                    const data = await response.json();\n                    addDataPoint(data);\n                }\n            } catch (error) {\n                console.error('Error fetching chart data:', error);\n            }\n        }\n        \n        // Add new data point to chart\n        function addDataPoint(data) {\n            if (!isLiveMode) return; // Don't add live data when viewing historical\n            \n            const timestamp = data.timestamp;\n            \n            // Add new data point\n            chartData.labels.push(timestamp);\n            chartData.datasets[0].data.push(data.pvProduction);\n            chartData.datasets[1].data.push(data.gridExport);\n            chartData.datasets[2].data.push(data.gridImport);\n            chartData.datasets[3].data.push(data.batteryCharge);\n            chartData.datasets[4].data.push(data.batteryDischarge);\n            \n            // Keep only last 50 data points for performance\n            const maxPoints = 50;\n            if (chartData.labels.length > maxPoints) {\n                chartData.labels.shift();\n                chartData.datasets.forEach(dataset => dataset.data.shift());\n            }\n            \n            // Update chart\n            if (powerChart) {\n                powerChart.update('none');\n            }\n        }\n        \n        // Load historical data for specified hours\n        async function loadHistoricalData(hours, buttonElement) {\n            try {\n                // Update button states\n                document.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));\n                buttonElement.classList.add('active');\n                \n                // Set to historical mode\n                isLiveMode = false;\n                \n                // Show loading state\n                const loadingText = 'Loading ' + hours + 'h data...';\n                console.log(loadingText);\n                \n                // Fetch historical data\n                const response = await fetch(`/historical-power-data?hours=${hours}&limit=500`);\n                if (!response.ok) {\n                    throw new Error('Failed to fetch historical data');\n                }\n                \n                const result = await response.json();\n                if (!result.success || !result.data) {\n                    throw new Error('Invalid historical data response');\n                }\n                \n                // Replace chart data with historical data\n                powerChart.data = result.data;\n                powerChart.update('active');\n                \n                console.log(`Loaded ${result.meta.count} historical data points for ${hours} hours`);\n                \n            } catch (error) {\n                console.error('Error loading historical data:', error);\n                alert('Failed to load historical data. Please try again.');\n                \n                // Revert to live mode on error\n                switchToLive(buttonElement);\n            }\n        }\n        \n        // Switch back to live mode\n        function switchToLive(buttonElement) {\n            // Update button states\n            document.querySelectorAll('.time-range-btn').forEach(btn => btn.classList.remove('active'));\n            buttonElement.classList.add('active');\n            \n            // Clear historical data and reset to live mode\n            chartData.labels = [];\n            chartData.datasets.forEach(dataset => {\n                dataset.data = [];\n            });\n            \n            // Update chart with empty data\n            powerChart.data = chartData;\n            powerChart.update('active');\n            \n            // Enable live mode\n            isLiveMode = true;\n            \n            // Immediately fetch current data\n            updateChartData();\n            \n            console.log('Switched to live mode');\n        }\n        \n        // Toggle light function\n        async function toggleLight(deviceId, currentState) {\n            const tile = document.querySelector(`[data-device-id=\"${deviceId}\"]`);\n            const newState = currentState === 'on' ? 'off' : 'on';\n            \n            // Add loading state\n            tile.classList.add('loading');\n            \n            try {\n                const response = await fetch(`/hubitat-control/${deviceId}/${newState}`, {\n                    method: 'POST'\n                });\n                \n                if (response.ok) {\n                    // Update tile state immediately for better UX\n                    tile.classList.remove('on', 'off', 'error');\n                    tile.classList.add(newState);\n                    tile.setAttribute('onclick', `toggleLight(${deviceId}, '${newState}')`);\n                } else {\n                    throw new Error('Failed to control device');\n                }\n            } catch (error) {\n                console.error('Error controlling light:', error);\n                tile.classList.add('error');\n                setTimeout(() => tile.classList.remove('error'), 3000);\n            } finally {\n                tile.classList.remove('loading');\n            }\n        }\n        \n        // Refresh dashboard data\n        async function refreshDashboard() {\n            try {\n                const response = await fetch('/hubitat-status');\n                if (response.ok) {\n                    const data = await response.json();\n                    updateDashboard(data);\n                    updateBattery(data.battery);\n                    document.getElementById('statusText').textContent = 'Connected';\n                    document.getElementById('statusText').className = 'status-online';\n                } else {\n                    throw new Error('Failed to fetch status');\n                }\n            } catch (error) {\n                console.error('Error refreshing dashboard:', error);\n                document.getElementById('statusText').textContent = 'Offline';\n                document.getElementById('statusText').className = 'status-offline';\n            }\n            \n            // Also refresh weather data\n            fetchWeatherData();\n            \n            // Also refresh chart data\n            updateChartData();\n        }\n        \n        // Update dashboard with new data\n        function updateDashboard(data) {\n            data.lights.forEach(light => {\n                const tile = document.querySelector(`[data-device-id=\"${light.id}\"]`);\n                if (tile) {\n                    tile.classList.remove('on', 'off', 'error');\n                    tile.classList.add(light.state);\n                    tile.setAttribute('onclick', `toggleLight(${light.id}, '${light.state}')`);\n                }\n            });\n            \n            document.getElementById('lastUpdate').textContent = formatTimestamp(data.timestamp);\n        }\n        \n        // Update battery display\n        function updateBattery(batteryData) {\n            if (!batteryData) return;\n            \n            try {\n                const chargingSymbol = document.getElementById('chargingSymbol');\n                const batteryTile = document.getElementById('batteryTile');\n                const batteryFill = document.getElementById('batteryFill');\n                const batteryPercentage = batteryTile.querySelector('.battery-percentage');\n                const stateFont = document.getElementById('stateFont');\n                \n                // Update percentage text\n                if (batteryPercentage) {\n                    batteryPercentage.textContent = (batteryData.SOC || 0) + '%';\n                }\n                \n                // Validate SOC value\n                const validSOC = Math.max(0, Math.min(100, batteryData.SOC || 0));\n                \n                // Set battery fill width\n                batteryFill.style.width = validSOC + '%';\n                \n                // Set battery color based on SOC level\n                let batteryColor;\n                if (validSOC < 20) batteryColor = '#ff4444';\n                else if (validSOC < 40) batteryColor = '#ff9100';\n                else if (validSOC < 60) batteryColor = '#fff200';\n                else if (validSOC < 80) batteryColor = '#d7fc03';\n                else batteryColor = '#00ff00';\n                \n                batteryFill.style.background = batteryColor;\n                \n                // Clear previous state classes\n                batteryTile.classList.remove('battery-charging', 'battery-discharging', 'battery-idle');\n\n                // Handle charging state\n                if (batteryData.state && batteryData.state.toLowerCase() === 'charging') {\n                    stateFont.style.color = '#00ff00';\n                    stateFont.classList.remove('flashfont');\n                    chargingSymbol.style.display = 'block';\n                    chargingSymbol.classList.add('flash');\n                    batteryTile.classList.add('battery-charging');\n                    stateFont.innerHTML = \"charging\";\n                } else {\n                    chargingSymbol.style.display = 'none';\n                    chargingSymbol.classList.remove('flash');\n                    if (batteryData.state && batteryData.state.toLowerCase() === 'discharging') {\n                        batteryTile.classList.add('battery-discharging');\n                        stateFont.style.color = '#ff6b6b';\n                        stateFont.classList.add('flashfont');\n                        stateFont.innerHTML = \"discharging\";\n                    } else {\n                        batteryTile.classList.add('battery-idle');\n                        stateFont.style.color = '#ffffff';\n                        stateFont.classList.remove('flashfont');\n                        stateFont.innerHTML = \"idle\";\n                    }\n                }\n            } catch (error) {\n                console.warn('Battery update error:', error);\n            }\n        }\n        \n        // Start polling for updates every 10 seconds\n        if (isPolling) {\n            setInterval(refreshDashboard, 10000);\n        }\n        \n        // Add keyboard navigation\n        document.addEventListener('keydown', function(event) {\n            if (event.key === 'r' || event.key === 'R') {\n                refreshDashboard();\n            }\n        });\n        \n        console.log('Hubitat Dashboard loaded with {{payload.lights.length}} lights');\n    </script>\n</body>\n</html>",
        "output": "str",
        "x": 770,
        "y": 340,
        "wires": [
            [
                "h8a9b0c1d2e3f4g5"
            ]
        ]
    },
    {
        "id": "h8a9b0c1d2e3f4g5",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Dashboard Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "text/html"
        },
        "x": 1070,
        "y": 340,
        "wires": []
    },
    {
        "id": "h9a0b1c2d3e4f5g6",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Device Control Endpoint",
        "url": "/hubitat-control/:deviceId/:command",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 240,
        "wires": [
            [
                "h0a1b2c3d4e5f6g7"
            ]
        ]
    },
    {
        "id": "h0a1b2c3d4e5f6g7",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Prepare Control Command",
        "func": "// Extract device ID and command from URL parameters\nconst deviceId = msg.req.params.deviceId;\nconst command = msg.req.params.command;\n\n// Validate command\nif (command !== 'on' && command !== 'off') {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Invalid command. Use on or off.' };\n    return msg;\n}\n\n// Validate device ID\nif (!deviceId || isNaN(parseInt(deviceId))) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Invalid device ID.' };\n    return msg;\n}\n\n// Prepare the Hubitat API URL\nconst baseUrl = 'http://172.17.98.214/apps/api/93/devices';\nconst accessToken = 'c978917f-7089-4041-937f-414a0bb2ab6d';\nconst url = `${baseUrl}/${deviceId}/${command}?access_token=${accessToken}`;\n\nmsg.url = url;\nmsg.method = 'GET';\nmsg.deviceId = deviceId;\nmsg.command = command;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 240,
        "wires": [
            [
                "h1a2b3c4d5e6f7g8_control"
            ]
        ]
    },
    {
        "id": "h1a2b3c4d5e6f7g8_control",
        "type": "http request",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Send Control to Hubitat",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 790,
        "y": 240,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9_response"
            ]
        ]
    },
    {
        "id": "h2a3b4c5d6e7f8g9_response",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Format Control Response",
        "func": "// Prepare response\nconst response = {\n    success: true,\n    deviceId: msg.deviceId,\n    command: msg.command,\n    timestamp: new Date().toISOString(),\n    hubitatResponse: msg.payload\n};\n\nmsg.payload = response;\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 240,
        "wires": [
            [
                "h3a4b5c6d7e8f9g0_response",
                "cccde8f277d49879"
            ]
        ]
    },
    {
        "id": "h3a4b5c6d7e8f9g0_response",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Control Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1690,
        "y": 240,
        "wires": []
    },
    {
        "id": "h4a5b6c7d8e9f0g1_status",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Status API Endpoint",
        "url": "/hubitat-status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 420,
        "wires": [
            [
                "h5a6b7c8d9e0f1g2_status"
            ]
        ]
    },
    {
        "id": "h5a6b7c8d9e0f1g2_status",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Get Current Status",
        "func": "// Get the light devices from global context\nconst lightDevices = global.get('hubitatLights') || [];\n\n// Get the battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'unknown',\n    time: new Date().toISOString()\n};\n\n// Process devices to get current status\nconst processedLights = lightDevices.map(device => {\n    // Determine current state based on device attributes\n    let isOn = false;\n    if (device.attributes) {\n        // Handle both array and object formats\n        if (Array.isArray(device.attributes)) {\n            const switchAttr = device.attributes.find(attr => attr.name === 'switch');\n            isOn = switchAttr && switchAttr.currentValue === 'on';\n        } else if (device.attributes.switch) {\n            isOn = device.attributes.switch === 'on';\n        }\n    }\n    \n    return {\n        id: device.id,\n        name: device.label || device.name,\n        state: isOn ? 'on' : 'off',\n        type: device.type || 'Light'\n    };\n});\n\nmsg.payload = {\n    lights: processedLights,\n    battery: batteryData,\n    timestamp: new Date().toISOString(),\n    status: 'ok'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 420,
        "wires": [
            [
                "h6a7b8c9d0e1f2g3_status"
            ]
        ]
    },
    {
        "id": "h6a7b8c9d0e1f2g3_status",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Status Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 750,
        "y": 420,
        "wires": []
    },
    {
        "id": "h3a4b5c6d7e8f9g0",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Filter Light Devices",
        "func": "// Target light device IDs\nconst targetIds = [17, 1, 2, 3, 4, 20, 5];\n\n// Filter devices to only include our target lights\nconst allDevices = msg.payload;\nconst lightDevices = allDevices.filter(device => targetIds.includes(parseInt(device.id)));\n\n// Store filtered devices in global context\nglobal.set('hubitatLights', lightDevices);\n\n// Return the filtered devices\nmsg.payload = lightDevices;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "h4a5b6c7d8e9f0g1",
        "type": "debug",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Light Devices Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 120,
        "wires": []
    },
    {
        "id": "cccde8f277d49879",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Trigger status update.",
        "func": "// Prepare response\nmsg.payload = new Date().getTime(); // returns milliseconds\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 200,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "g1a2b3c4d5e6f7g8",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Power Graph API",
        "url": "/power-graph-data",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 200,
        "y": 580,
        "wires": [
            [
                "g2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "g2a3b4c5d6e7f8g9",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Get Power Graph Data",
        "func": "// Get stored power graph data\nconst powerData = global.get('powerGraphData') || {\n    pv1watt: 0,\n    pactogridr: 0,\n    pactouserr: 0,\n    p1charge1: 0,\n    pdischarge1: 0,\n    lastupdated: new Date().toISOString()\n};\n\n// Convert to kilowatts and format for chart\nconst chartData = {\n    timestamp: powerData.lastupdated,\n    pvProduction: (powerData.pv1watt || 0) / 1000,\n    gridExport: (powerData.pactogridr || 0) / 1000,\n    gridImport: (powerData.pactouserr || 0) / 1000,\n    batteryCharge: (powerData.p1charge1 || 0) / 1000,\n    batteryDischarge: (powerData.pdischarge1 || 0) / 1000\n};\n\nmsg.payload = chartData;\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 580,
        "wires": [
            [
                "g3a4b5c6d7e8f9g0"
            ]
        ]
    },
    {
        "id": "g3a4b5c6d7e8f9g0",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Graph Data Response",
        "statusCode": "",
        "headers": {},
        "x": 690,
        "y": 580,
        "wires": []
    },
    {
        "id": "w1a2b3c4d5e6f7g8",
        "type": "inject",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Fetch Weather Every 10 Min",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 80,
        "wires": [
            [
                "w2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "w2a3b4c5d6e7f8g9",
        "type": "exec",
        "z": "c9f1a2b3d4e5f6g7",
        "command": "curl",
        "addpay": "payload",
        "append": "-s ftp://ftp.bom.gov.au/anon/gen/fwo/IDS60920.xml",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Get BOM Weather Data",
        "x": 510,
        "y": 80,
        "wires": [
            [
                "w3a4b5c6d7e8f9g0"
            ],
            [],
            []
        ]
    },
    {
        "id": "w3a4b5c6d7e8f9g0",
        "type": "xml",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Parse XML",
        "property": "payload",
        "attr": "attr",
        "chr": "",
        "x": 770,
        "y": 60,
        "wires": [
            [
                "w4a5b6c7d8e9f0g1"
            ]
        ]
    },
    {
        "id": "w4a5b6c7d8e9f0g1",
        "type": "function",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Extract Weather Data",
        "func": "// Extract weather data for Adelaide area stations with enhanced debugging\nconst weatherData = {};\nconst stations = [];\n\ntry {\n    // Debug: Log the structure we received\n    //node.warn('Received payload structure: ' + JSON.stringify(Object.keys(msg.payload), null, 2));\n    \n    // Handle different possible XML structures\n    let observations;\n    if (msg.payload.product && msg.payload.product.observations) {\n        observations = msg.payload.product.observations;\n    } else if (msg.payload.observations) {\n        observations = msg.payload.observations;\n    } else {\n        node.warn('Cannot find observations in payload');\n        throw new Error('No observations found in XML structure');\n    }\n    \n    //node.warn('Found observations: ' + JSON.stringify(Object.keys(observations), null, 2));\n    \n    // Check if observations is an array and get the first element\n    if (Array.isArray(observations) && observations.length > 0) {\n        observations = observations[0];\n        node.warn('Using first observations array element');\n    } else if (observations['0']) {\n        // Sometimes XML parser creates indexed objects instead of arrays\n        observations = observations['0'];\n        node.warn('Using indexed observations element');\n    }\n    \n    //node.warn('Observations structure after processing: ' + JSON.stringify(Object.keys(observations), null, 2));\n    \n    if (observations && observations.station) {\n        const stationArray = Array.isArray(observations.station) ? observations.station : [observations.station];\n        //node.warn(`Processing ${stationArray.length} stations`);\n        \n        // Look for stations near Banksia Park\n        const targetStations = ['PARAFIELD', 'ADELAIDE AIRPORT', 'ADELAIDE (WEST TERRACE', 'WEST TERRACE'];\n        \n        stationArray.forEach((station, index) => {\n            try {\n                // Handle both attribute structures: station.$ or station.attr\n                const attrs = station.$ || station.attr || station;\n                const stationName = attrs['stn-name'] || attrs.stnName || 'Unknown';\n                \n                //node.warn(`Station ${index}: ${stationName}`);\n                \n                // Check if this is a station we want\n                const isTargetStation = targetStations.some(target => \n                    stationName.toUpperCase().includes(target.toUpperCase())\n                );\n                \n                if (isTargetStation) {\n                    //node.warn(`Processing target station: ${stationName}`);\n                    \n                    // Get the most recent period (usually index 0)\n                    const period = Array.isArray(station.period) ? station.period[0] : station.period;\n                    if (!period) {\n                        node.warn('No period data found for station: ' + stationName);\n                        return;\n                    }\n                    \n                    // Get surface level data\n                    const level = Array.isArray(period.level) ? period.level[0] : period.level;\n                    if (!level) {\n                        node.warn('No level data found for station: ' + stationName);\n                        return;\n                    }\n                    \n                    // Initialize station data\n                    const stationData = {\n                        station_name: stationName,\n                        station_id: attrs['bom-id'] || attrs.bomId || 'unknown',\n                        latitude: parseFloat(attrs['lat'] || attrs.latitude || 0),\n                        longitude: parseFloat(attrs['lon'] || attrs.longitude || 0),\n                        timestamp: (period.$ || period.attr || period)['time-utc'] || new Date().toISOString(),\n                        local_time: (period.$ || period.attr || period)['time-local'] || new Date().toLocaleString()\n                    };\n                    \n                    // Process elements\n                    if (level.element) {\n                        const elements = Array.isArray(level.element) ? level.element : [level.element];\n                        //node.warn(`Found ${elements.length} elements for ${stationName}`);\n                        \n                        elements.forEach(element => {\n                            const elementAttrs = element.$ || element.attr || element;\n                            const type = elementAttrs.type || elementAttrs['type'];\n                            const value = element._ || element.value || element;\n                            const units = elementAttrs.units || elementAttrs['units'];\n                            \n                            if (type && value !== undefined && value !== null) {\n                                switch(type) {\n                                    case 'air_temperature':\n                                        stationData.temperature = parseFloat(value);\n                                        stationData.temperature_units = units;\n                                        break;\n                                    case 'apparent_temp':\n                                        stationData.apparent_temperature = parseFloat(value);\n                                        break;\n                                    case 'dew_point':\n                                        stationData.dew_point = parseFloat(value);\n                                        break;\n                                    case 'rel-humidity':\n                                        stationData.humidity = parseFloat(value);\n                                        stationData.humidity_units = units;\n                                        break;\n                                    case 'wind_spd_kmh':\n                                        stationData.wind_speed = parseFloat(value);\n                                        stationData.wind_speed_units = units;\n                                        break;\n                                    case 'wind_dir':\n                                        stationData.wind_direction = value;\n                                        break;\n                                    case 'wind_dir_deg':\n                                        stationData.wind_direction_degrees = parseFloat(value);\n                                        break;\n                                    case 'gust_kmh':\n                                        stationData.wind_gust = parseFloat(value);\n                                        break;\n                                    case 'msl_pres':\n                                        stationData.pressure = parseFloat(value);\n                                        stationData.pressure_units = units;\n                                        break;\n                                    case 'rainfall':\n                                        const duration = elementAttrs.duration || elementAttrs['duration'];\n                                        stationData.rainfall_since_9am = parseFloat(value);\n                                        break;\n                                    case 'rainfall_24hr':\n                                        stationData.rainfall_24hr = parseFloat(value);\n                                        break;\n                                    case 'vis_km':\n                                        stationData.visibility = parseFloat(value);\n                                        stationData.visibility_units = units;\n                                        break;\n                                    case 'cloud':\n                                        stationData.cloud_description = value;\n                                        break;\n                                    case 'cloud_oktas':\n                                        stationData.cloud_oktas = parseFloat(value);\n                                        break;\n                                    case 'minimum_air_temperature':\n                                        stationData.min_temperature = parseFloat(value);\n                                        break;\n                                    case 'maximum_air_temperature':\n                                        stationData.max_temperature = parseFloat(value);\n                                        break;\n                                }\n                            }\n                        });\n                    }\n                    \n                    stations.push(stationData);\n                    //node.warn(`Added station data for: ${stationName}`);\n                }\n            } catch (stationError) {\n                node.warn(`Error processing station ${index}: ${stationError.message}`);\n            }\n        });\n    }\n    \n    node.warn(`Total stations processed: ${stations.length}`);\n    \n    // Find the best station (prefer Parafield, then Adelaide Airport)\n    let selectedStation = null;\n    \n    for (const station of stations) {\n        if (station.station_name.toUpperCase().includes('PARAFIELD')) {\n            selectedStation = station;\n            break;\n        }\n    }\n    \n    if (!selectedStation) {\n        for (const station of stations) {\n            if (station.station_name.toUpperCase().includes('ADELAIDE AIRPORT')) {\n                selectedStation = station;\n                break;\n            }\n        }\n    }\n    \n    if (!selectedStation && stations.length > 0) {\n        selectedStation = stations[0];\n    }\n    \n    if (selectedStation) {\n        // Prepare final weather data\n        weatherData.temperature = selectedStation.temperature || null;\n        weatherData.apparent_temperature = selectedStation.apparent_temperature || null;\n        weatherData.min_temperature = selectedStation.min_temperature || null;\n        weatherData.max_temperature = selectedStation.max_temperature || null;\n        weatherData.humidity = selectedStation.humidity || null;\n        weatherData.pressure = selectedStation.pressure || null;\n        weatherData.wind_speed = selectedStation.wind_speed || null;\n        weatherData.wind_direction = selectedStation.wind_direction || null;\n        weatherData.wind_gust = selectedStation.wind_gust || null;\n        weatherData.rainfall_24hr = selectedStation.rainfall_24hr || 0;\n        weatherData.rainfall_since_9am = selectedStation.rainfall_since_9am || 0;\n        weatherData.visibility = selectedStation.visibility || null;\n        weatherData.cloud_description = selectedStation.cloud_description || null;\n        weatherData.dew_point = selectedStation.dew_point || null;\n        weatherData.station_name = selectedStation.station_name;\n        weatherData.timestamp = selectedStation.timestamp;\n        weatherData.local_time = selectedStation.local_time;\n        weatherData.latitude = selectedStation.latitude;\n        weatherData.longitude = selectedStation.longitude;\n        weatherData.last_updated = new Date().toISOString();\n        \n        // Store in global context\n        global.set('weather_data', weatherData);\n        \n        msg.payload = weatherData;\n        node.status({fill:\"green\",shape:\"dot\",text:`Updated: ${selectedStation.station_name.substring(0, 20)}`});\n        //node.warn('Weather data successfully processed and stored');\n        \n        return msg;\n    } else {\n        node.status({fill:\"red\",shape:\"ring\",text:\"No target stations found\"});\n        node.warn('No target stations found in the data');\n        return null;\n    }\n    \n} catch (error) {\n    node.error('Weather parsing error: ' + error.message);\n    node.warn('Full error: ' + JSON.stringify(error, null, 2));\n    node.status({fill:\"red\",shape:\"ring\",text:`Error: ${error.message.substring(0, 20)}`});\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 60,
        "wires": [
            [
                "w5a6b7c8d9e0f1g2"
            ]
        ]
    },
    {
        "id": "w5a6b7c8d9e0f1g2",
        "type": "mqtt out",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Publish Weather to MQTT",
        "topic": "weather/current",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d4045e31a39c5762",
        "x": 1270,
        "y": 60,
        "wires": []
    },
    {
        "id": "w7a8b9c0d1e2f3g4",
        "type": "http in",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Weather API Endpoint",
        "url": "/weather",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 140,
        "wires": [
            [
                "w8a9b0c1d2e3f4g5"
            ]
        ]
    },
    {
        "id": "w8a9b0c1d2e3f4g5",
        "type": "function",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Get Current Weather",
        "func": "// Get weather data from global context\nconst weatherData = global.get('weather_data') || {};\n\nif (Object.keys(weatherData).length === 0) {\n    msg.payload = {\n        error: 'No weather data available',\n        message: 'Weather data is being fetched. Please try again in a few minutes.'\n    };\n    msg.statusCode = 503;\n} else {\n    msg.payload = weatherData;\n    msg.statusCode = 200;\n}\n\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 140,
        "wires": [
            [
                "w9a0b1c2d3e4f5g6"
            ]
        ]
    },
    {
        "id": "w9a0b1c2d3e4f5g6",
        "type": "http response",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Weather Response",
        "statusCode": "",
        "headers": {},
        "x": 630,
        "y": 140,
        "wires": []
    },
    {
        "id": "gw_current_inject",
        "type": "inject",
        "z": "google_weather_tab",
        "name": "Current Weather (30min)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "1800",
        "crontab": "",
        "once": true,
        "onceDelay": 10,
        "topic": "",
        "payload": "current",
        "payloadType": "str",
        "x": 410,
        "y": 120,
        "wires": [
            [
                "gw_current_request"
            ]
        ]
    },
    {
        "id": "gw_forecast_inject",
        "type": "inject",
        "z": "google_weather_tab",
        "name": "10-Day Forecast (4hr)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "14400",
        "crontab": "",
        "once": true,
        "onceDelay": 30,
        "topic": "",
        "payload": "forecast",
        "payloadType": "str",
        "x": 410,
        "y": 240,
        "wires": [
            [
                "gw_forecast_request"
            ]
        ]
    },
    {
        "id": "gw_current_request",
        "type": "http request",
        "z": "google_weather_tab",
        "name": "Get Current Weather",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://weather.googleapis.com/v1/currentConditions:lookup?key=AIzaSyDcCgEHqXpmJrO8sxxRMxLSbZjM2n3GiWM&location.latitude=-34.8105248&location.longitude=138.7305864",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 660,
        "y": 120,
        "wires": [
            [
                "gw_current_parser"
            ]
        ]
    },
    {
        "id": "gw_forecast_request",
        "type": "http request",
        "z": "google_weather_tab",
        "name": "Get 10-Day Forecast",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://weather.googleapis.com/v1/forecast/days:lookup?key=AIzaSyDcCgEHqXpmJrO8sxxRMxLSbZjM2n3GiWM&location.latitude=-34.8105248&location.longitude=138.7305864&days=10",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 660,
        "y": 240,
        "wires": [
            [
                "gw_forecast_parser"
            ]
        ]
    },
    {
        "id": "gw_current_parser",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Parse Current Weather",
        "func": "// Parse Google Weather API current conditions response\ntry {\n    const data = msg.payload;\n    \n    if (!data || !data.temperature) {\n        node.error(\"Invalid weather data received\", msg);\n        return null;\n    }\n    \n    // Extract key weather metrics with proper null handling\n    const now = new Date();\n    now.setMinutes(0, 0, 0);\n    const timestamp = now.toISOString();\n    // const timestamp = new Date().toISOString();\n    const temperature = data.temperature?.degrees || null;\n    const feels_like = data.feelsLikeTemperature?.degrees || null;\n    const humidity = data.relativeHumidity || null;\n    const pressure = data.airPressure?.meanSeaLevelMillibars || null;\n    const wind_speed = data.wind?.speed?.value || null;\n    const wind_direction = data.wind?.direction?.degrees || null;\n    const wind_cardinal = data.wind?.direction?.cardinal || null;\n    const condition = data.weatherCondition?.description?.text || null;\n    const condition_type = data.weatherCondition?.type || null;\n    const uv_index = data.uvIndex || null;\n    const visibility = data.visibility?.distance || null;\n    const dew_point = data.dewPoint?.degrees || null;\n    const cloud_cover = data.cloudCover || null;\n    const precipitation_prob = data.precipitation?.probability?.percent || null;\n    const is_daytime = data.isDaytime ? 1 : 0;\n    \n    // Create direct SQL insert with values (not parameterized)\n    const sql = `INSERT OR REPLACE INTO weather_current \n        (timestamp, temperature, feels_like, humidity, pressure, wind_speed, \n         wind_direction, wind_cardinal, condition, condition_type, uv_index, \n         visibility, dew_point, cloud_cover, precipitation_prob, is_daytime) \n        VALUES (\n            '${timestamp}',\n            ${temperature},\n            ${feels_like},\n            ${humidity},\n            ${pressure},\n            ${wind_speed},\n            ${wind_direction},\n            '${wind_cardinal}',\n            '${condition}',\n            '${condition_type}',\n            ${uv_index},\n            ${visibility},\n            ${dew_point},\n            ${cloud_cover},\n            ${precipitation_prob},\n            ${is_daytime}\n        )`;\n    \n    msg.topic = sql;\n    msg.payload = []; // Empty array for direct SQL\n    \n    // Log successful parse\n    node.log(`Parsed current weather: ${temperature}°C, ${condition}`);\n    \n    return msg;\n    \n} catch (error) {\n    node.error(`Error parsing current weather: ${error.message}`, msg);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 120,
        "wires": [
            [
                "gw_current_store"
            ]
        ]
    },
    {
        "id": "gw_forecast_parser",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Parse 10-Day Forecast",
        "func": "// Parse Google Weather API 10-day forecast response\ntry {\n    const data = msg.payload;\n    \n    if (!data || !data.forecastDays || !Array.isArray(data.forecastDays)) {\n        node.error(\"Invalid forecast data received\", msg);\n        return null;\n    }\n    const now = new Date();\n    now.setMinutes(0, 0, 0);\n    const timestamp = now.toISOString();    \n    // const timestamp = new Date().toISOString();\n    const messages = [];\n    \n    // Process each forecast day\n    data.forecastDays.forEach((day, index) => {\n        // Extract and prepare forecast data\n        const forecast_date = day.displayDate ? \n            `${day.displayDate.year}-${String(day.displayDate.month).padStart(2, '0')}-${String(day.displayDate.day).padStart(2, '0')}` \n            : null;\n        const day_number = index + 1;\n        const min_temp = day.minTemperature?.degrees || null;\n        const max_temp = day.maxTemperature?.degrees || null;\n        const min_feels_like = day.feelsLikeMinTemperature?.degrees || null;\n        const max_feels_like = day.feelsLikeMaxTemperature?.degrees || null;\n        const day_condition = day.daytimeForecast?.weatherCondition?.description?.text || null;\n        const day_condition_type = day.daytimeForecast?.weatherCondition?.type || null;\n        const night_condition = day.nighttimeForecast?.weatherCondition?.description?.text || null;\n        const night_condition_type = day.nighttimeForecast?.weatherCondition?.type || null;\n        const precipitation_prob_day = day.daytimeForecast?.precipitation?.probability?.percent || null;\n        const precipitation_prob_night = day.nighttimeForecast?.precipitation?.probability?.percent || null;\n        const precipitation_amount_day = day.daytimeForecast?.precipitation?.qpf?.quantity || null;\n        const precipitation_amount_night = day.nighttimeForecast?.precipitation?.qpf?.quantity || null;\n        const wind_speed_day = day.daytimeForecast?.wind?.speed?.value || null;\n        const wind_speed_night = day.nighttimeForecast?.wind?.speed?.value || null;\n        const wind_direction_day = day.daytimeForecast?.wind?.direction?.degrees || null;\n        const wind_direction_night = day.nighttimeForecast?.wind?.direction?.degrees || null;\n        const humidity_day = day.daytimeForecast?.relativeHumidity || null;\n        const humidity_night = day.nighttimeForecast?.relativeHumidity || null;\n        const uv_index = day.daytimeForecast?.uvIndex || null;\n        const sunrise_time = day.sunEvents?.sunriseTime || null;\n        const sunset_time = day.sunEvents?.sunsetTime || null;\n        const moon_phase = day.moonEvents?.moonPhase || null;\n        \n        // Create direct SQL insert\n        const sql = `INSERT OR REPLACE INTO weather_forecast \n            (timestamp, forecast_date, day_number, min_temp, max_temp, min_feels_like, max_feels_like,\n             day_condition, day_condition_type, night_condition, night_condition_type,\n             precipitation_prob_day, precipitation_prob_night, precipitation_amount_day, precipitation_amount_night,\n             wind_speed_day, wind_speed_night, wind_direction_day, wind_direction_night,\n             humidity_day, humidity_night, uv_index, sunrise_time, sunset_time, moon_phase) \n            VALUES (\n                '${timestamp}',\n                '${forecast_date}',\n                ${day_number},\n                ${min_temp},\n                ${max_temp},\n                ${min_feels_like},\n                ${max_feels_like},\n                '${day_condition}',\n                '${day_condition_type}',\n                '${night_condition}',\n                '${night_condition_type}',\n                ${precipitation_prob_day},\n                ${precipitation_prob_night},\n                ${precipitation_amount_day},\n                ${precipitation_amount_night},\n                ${wind_speed_day},\n                ${wind_speed_night},\n                ${wind_direction_day},\n                ${wind_direction_night},\n                ${humidity_day},\n                ${humidity_night},\n                ${uv_index},\n                '${sunrise_time}',\n                '${sunset_time}',\n                '${moon_phase}'\n            )`;\n        \n        const dayMsg = {\n            topic: sql,\n            payload: [] // Empty array for direct SQL\n        };\n        \n        messages.push(dayMsg);\n    });\n    \n    // Log successful parse\n    node.log(`Parsed ${messages.length}-day forecast`);\n    \n    return [messages];\n    \n} catch (error) {\n    node.error(`Error parsing forecast: ${error.message}`, msg);\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 240,
        "wires": [
            [
                "gw_forecast_store"
            ]
        ]
    },
    {
        "id": "gw_current_store",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Store Current Weather",
        "x": 1150,
        "y": 120,
        "wires": [
            [
                "gw_current_debug"
            ]
        ]
    },
    {
        "id": "gw_forecast_store",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Store Forecast",
        "x": 1130,
        "y": 240,
        "wires": [
            [
                "gw_forecast_debug"
            ]
        ]
    },
    {
        "id": "gw_current_debug",
        "type": "debug",
        "z": "google_weather_tab",
        "name": "Current Weather Stored",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1400,
        "y": 120,
        "wires": []
    },
    {
        "id": "gw_forecast_debug",
        "type": "debug",
        "z": "google_weather_tab",
        "name": "Forecast Stored",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1370,
        "y": 240,
        "wires": []
    },
    {
        "id": "gw_cleanup_inject",
        "type": "inject",
        "z": "google_weather_tab",
        "name": "Cleanup Old Data (Daily)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "0 2 * * *",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "cleanup",
        "payloadType": "str",
        "x": 400,
        "y": 320,
        "wires": [
            [
                "gw_cleanup_current",
                "gw_cleanup_forecast"
            ]
        ]
    },
    {
        "id": "gw_cleanup_current",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "fixed",
        "sql": "DELETE FROM weather_current WHERE timestamp < datetime('now', '-10 days')",
        "name": "Cleanup Current (10d)",
        "x": 680,
        "y": 300,
        "wires": [
            [
                "gw_cleanup_debug"
            ]
        ]
    },
    {
        "id": "gw_cleanup_forecast",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "fixed",
        "sql": "DELETE FROM weather_forecast WHERE timestamp < datetime('now', '-30 days')",
        "name": "Cleanup Forecast (30d)",
        "x": 690,
        "y": 360,
        "wires": [
            [
                "gw_cleanup_debug"
            ]
        ]
    },
    {
        "id": "gw_cleanup_debug",
        "type": "debug",
        "z": "google_weather_tab",
        "name": "Cleanup Complete",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 970,
        "y": 320,
        "wires": []
    },
    {
        "id": "gw_manual_test",
        "type": "inject",
        "z": "google_weather_tab",
        "name": "Manual Test",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "test",
        "payloadType": "str",
        "x": 290,
        "y": 40,
        "wires": [
            [
                "gw_current_request",
                "gw_forecast_request"
            ]
        ]
    },
    {
        "id": "gw_http_endpoint",
        "type": "http in",
        "z": "google_weather_tab",
        "name": "Weather Collection API",
        "url": "/weather/collect",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 100,
        "y": 180,
        "wires": [
            [
                "gw_trigger_function"
            ]
        ]
    },
    {
        "id": "gw_trigger_function",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Trigger Both Collections",
        "func": "// Function to trigger both current weather and forecast collection\n// Send immediate response instead of waiting for completion\n\n// Create messages to trigger both endpoints\nconst currentMsg = {\n    payload: \"api_trigger\",\n    type: \"current\"\n};\n\nconst forecastMsg = {\n    payload: \"api_trigger\", \n    type: \"forecast\"\n};\n\n// Create immediate response\nconst responseMsg = {\n    payload: {\n        status: \"success\",\n        message: \"Weather data collection initiated\",\n        location: \"Banksia Park, SA\",\n        timestamp: new Date().toISOString(),\n        note: \"Data collection is running in background. Check the database for results.\",\n        sessionId: \"1234\" + new Date().toISOString()\n    },\n    statusCode: 200\n};\n\n// Log the trigger\nnode.log(`Weather collection triggered via API`);\n\n// Send trigger messages and response\nreturn [[currentMsg], [forecastMsg], [responseMsg]];",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 180,
        "wires": [
            [
                "gw_current_request"
            ],
            [
                "gw_forecast_request"
            ],
            [
                "gw_http_response"
            ]
        ]
    },
    {
        "id": "gw_http_response",
        "type": "http response",
        "z": "google_weather_tab",
        "name": "Weather API Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 950,
        "y": 180,
        "wires": []
    },
    {
        "id": "gw_response_tracker",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Track Collection Results",
        "func": "const response = {\n    status: \"success\",\n    message: \"Weather data collection completed\",\n    location: \"Banksia Park, SA\",\n    timestamp: new Date().toISOString()\n};\n\n// Prepare response message\nmsg.payload = response;\nmsg.statusCode = 200;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 180,
        "wires": [
            [
                "gw_http_response"
            ]
        ]
    },
    {
        "id": "weather_current_api",
        "type": "http in",
        "z": "google_weather_tab",
        "name": "Current Weather API",
        "url": "/weather/current",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 440,
        "wires": [
            [
                "get_current_weather"
            ]
        ]
    },
    {
        "id": "get_current_weather",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Get Current Weather Data",
        "func": "// Query latest current weather data from database\nconst sql = `SELECT \n    timestamp, temperature, feels_like, humidity, pressure,\n    wind_speed, wind_direction, wind_cardinal, condition, condition_type,\n    uv_index, visibility, dew_point, cloud_cover, precipitation_prob, is_daytime\nFROM weather_current \nORDER BY timestamp DESC \nLIMIT 1`;\n\nmsg.topic = sql;\nmsg.payload = [];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 440,
        "wires": [
            [
                "current_weather_db"
            ]
        ]
    },
    {
        "id": "current_weather_db",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Query Current Weather",
        "x": 690,
        "y": 440,
        "wires": [
            [
                "format_current_response"
            ]
        ]
    },
    {
        "id": "format_current_response",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Format Current Weather Response",
        "func": "// Format current weather data for API response\ntry {\n    const data = msg.payload;\n    \n    if (!data || data.length === 0) {\n        msg.payload = {\n            error: \"No current weather data available\",\n            timestamp: new Date().toISOString()\n        };\n        msg.statusCode = 404;\n        return msg;\n    }\n    \n    const weather = data[0];\n    \n    msg.payload = {\n        timestamp: weather.timestamp,\n        temperature: weather.temperature,\n        feels_like: weather.feels_like,\n        condition: weather.condition,\n        condition_type: weather.condition_type,\n        humidity: weather.humidity,\n        pressure: weather.pressure,\n        wind_speed: weather.wind_speed,\n        wind_direction: weather.wind_direction,\n        wind_cardinal: weather.wind_cardinal,\n        uv_index: weather.uv_index,\n        visibility: weather.visibility,\n        dew_point: weather.dew_point,\n        cloud_cover: weather.cloud_cover,\n        precipitation_prob: weather.precipitation_prob,\n        is_daytime: weather.is_daytime,\n        location: \"Banksia Park, SA\"\n    };\n    \n    msg.statusCode = 200;\n    msg.headers = {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\"\n    };\n    \n    return msg;\n    \n} catch (error) {\n    msg.payload = {\n        error: \"Error formatting weather data: \" + error.message,\n        timestamp: new Date().toISOString()\n    };\n    msg.statusCode = 500;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 440,
        "wires": [
            [
                "current_weather_response"
            ]
        ]
    },
    {
        "id": "current_weather_response",
        "type": "http response",
        "z": "google_weather_tab",
        "name": "Current Weather Response",
        "statusCode": "",
        "headers": {},
        "x": 1280,
        "y": 440,
        "wires": []
    },
    {
        "id": "weather_forecast_api",
        "type": "http in",
        "z": "google_weather_tab",
        "name": "Forecast API",
        "url": "/weather/forecast",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 160,
        "y": 500,
        "wires": [
            [
                "get_forecast_weather"
            ]
        ]
    },
    {
        "id": "get_forecast_weather",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Get Forecast Data",
        "func": "// Query latest forecast data from database\nconst sql = `SELECT \n    timestamp, forecast_date, day_number, min_temp, max_temp,\n    min_feels_like, max_feels_like, day_condition, day_condition_type,\n    night_condition, night_condition_type, precipitation_prob_day,\n    precipitation_prob_night, wind_speed_day, wind_speed_night,\n    humidity_day, humidity_night, uv_index\nFROM weather_forecast \nWHERE forecast_date >= date('now')\nORDER BY forecast_date ASC \nLIMIT 10`;\n\nmsg.topic = sql;\nmsg.payload = [];\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 500,
        "wires": [
            [
                "forecast_weather_db"
            ]
        ]
    },
    {
        "id": "forecast_weather_db",
        "type": "sqlite",
        "z": "google_weather_tab",
        "mydb": "gw_db_config",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "Query Forecast",
        "x": 620,
        "y": 500,
        "wires": [
            [
                "format_forecast_response"
            ]
        ]
    },
    {
        "id": "format_forecast_response",
        "type": "function",
        "z": "google_weather_tab",
        "name": "Format Forecast Response",
        "func": "// Format forecast data for API response\ntry {\n    const data = msg.payload;\n    \n    if (!data || data.length === 0) {\n        msg.payload = {\n            error: \"No forecast data available\",\n            timestamp: new Date().toISOString()\n        };\n        msg.statusCode = 404;\n        return msg;\n    }\n    \n    // Group forecast data by date and take the most recent timestamp for each date\n    const forecastMap = new Map();\n    \n    data.forEach(forecast => {\n        const date = forecast.forecast_date;\n        if (!forecastMap.has(date) || \n            new Date(forecast.timestamp) > new Date(forecastMap.get(date).timestamp)) {\n            forecastMap.set(date, forecast);\n        }\n    });\n    \n    // Convert to array and sort by date\n    const forecasts = Array.from(forecastMap.values())\n        .sort((a, b) => new Date(a.forecast_date) - new Date(b.forecast_date))\n        .map(forecast => ({\n            forecast_date: forecast.forecast_date,\n            day_number: forecast.day_number,\n            min_temp: forecast.min_temp,\n            max_temp: forecast.max_temp,\n            min_feels_like: forecast.min_feels_like,\n            max_feels_like: forecast.max_feels_like,\n            day_condition: forecast.day_condition,\n            day_condition_type: forecast.day_condition_type,\n            night_condition: forecast.night_condition,\n            night_condition_type: forecast.night_condition_type,\n            precipitation_prob_day: forecast.precipitation_prob_day,\n            precipitation_prob_night: forecast.precipitation_prob_night,\n            wind_speed_day: forecast.wind_speed_day,\n            wind_speed_night: forecast.wind_speed_night,\n            humidity_day: forecast.humidity_day,\n            humidity_night: forecast.humidity_night,\n            uv_index: forecast.uv_index,\n            timestamp: forecast.timestamp\n        }));\n    \n    msg.payload = forecasts;\n    msg.statusCode = 200;\n    msg.headers = {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\"\n    };\n    \n    return msg;\n    \n} catch (error) {\n    msg.payload = {\n        error: \"Error formatting forecast data: \" + error.message,\n        timestamp: new Date().toISOString()\n    };\n    msg.statusCode = 500;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 880,
        "y": 500,
        "wires": [
            [
                "forecast_weather_response"
            ]
        ]
    },
    {
        "id": "forecast_weather_response",
        "type": "http response",
        "z": "google_weather_tab",
        "name": "Forecast Response",
        "statusCode": "",
        "headers": {},
        "x": 1170,
        "y": 500,
        "wires": []
    },
    {
        "id": "uibuilder_node",
        "type": "uibuilder",
        "z": "uibuilder_dashboard_tab",
        "name": "Home Dashboard",
        "topic": "",
        "url": "dashboard",
        "okToGo": true,
        "fwdInMessages": false,
        "allowScripts": false,
        "allowStyles": false,
        "copyIndex": true,
        "templateFolder": "blank",
        "extTemplate": "",
        "showfolder": false,
        "oldUrl": "",
        "reload": true,
        "sourceFolder": "src",
        "deployedVersion": "7.4.3",
        "showMsgUib": false,
        "title": "",
        "descr": "",
        "editurl": "",
        "x": 390,
        "y": 660,
        "wires": [
            [
                "handle_ui_output"
            ],
            []
        ]
    },
    {
        "id": "handle_ui_output",
        "type": "switch",
        "z": "uibuilder_dashboard_tab",
        "name": "Route UI Commands",
        "property": "topic",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "control",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "request",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 720,
        "y": 660,
        "wires": [
            [
                "handle_control"
            ],
            [
                "send_initial_data"
            ]
        ]
    },
    {
        "id": "handle_control",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Handle Light Control",
        "func": "// Extract control payload\nconst control = msg.payload;\n\nif (control.type === 'light') {\n    // Prepare Hubitat API URL\n    const baseUrl = 'http://172.17.98.214/apps/api/93/devices';\n    const accessToken = 'c978917f-7089-4041-937f-414a0bb2ab6d';\n    \n    msg.url = `${baseUrl}/${control.deviceId}/${control.command}?access_token=${accessToken}`;\n    msg.method = 'GET';\n    msg.deviceId = control.deviceId;\n    msg.command = control.command;\n    \n    return msg;\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 620,
        "wires": [
            [
                "send_to_hubitat"
            ]
        ]
    },
    {
        "id": "send_to_hubitat",
        "type": "http request",
        "z": "uibuilder_dashboard_tab",
        "name": "Send to Hubitat",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1220,
        "y": 620,
        "wires": [
            [
                "trigger_lights_update"
            ]
        ]
    },
    {
        "id": "trigger_lights_update",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Trigger Update",
        "func": "msg.payload = new Date().getTime();\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 620,
        "wires": [
            [
                "fetch_lights"
            ]
        ]
    },
    {
        "id": "send_initial_data",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Request All Data",
        "func": "// Trigger all data fetches\nreturn [\n    {payload: 'lights'},\n    {payload: 'battery'},\n    {payload: 'weather'},\n    {payload: 'solar'}\n];",
        "outputs": 4,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 970,
        "y": 760,
        "wires": [
            [
                "fetch_lights"
            ],
            [
                "fetch_battery"
            ],
            [
                "fetch_weather"
            ],
            [
                "fetch_solar"
            ]
        ]
    },
    {
        "id": "poll_lights",
        "type": "inject",
        "z": "uibuilder_dashboard_tab",
        "name": "Poll Lights (5s)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 80,
        "wires": [
            [
                "fetch_hubitat_devices"
            ]
        ]
    },
    {
        "id": "fetch_hubitat_devices",
        "type": "http request",
        "z": "uibuilder_dashboard_tab",
        "name": "Get Hubitat Devices",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://172.17.98.214/apps/api/93/devices/all?access_token=c978917f-7089-4041-937f-414a0bb2ab6d",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 390,
        "y": 80,
        "wires": [
            [
                "filter_lights"
            ]
        ]
    },
    {
        "id": "filter_lights",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Filter & Format Lights",
        "func": "// Target light device IDs\nconst targetIds = [17, 1, 2, 3, 4, 20, 5];\n\n// Filter devices\nconst allDevices = msg.payload;\nconst lightDevices = allDevices.filter(device => targetIds.includes(parseInt(device.id)));\n\n// Format for UI\nconst formattedLights = lightDevices.map(device => {\n    let isOn = false;\n    if (device.attributes) {\n        if (Array.isArray(device.attributes)) {\n            const switchAttr = device.attributes.find(attr => attr.name === 'switch');\n            isOn = switchAttr && switchAttr.currentValue === 'on';\n        } else if (device.attributes.switch) {\n            isOn = device.attributes.switch === 'on';\n        }\n    }\n    \n    return {\n        id: device.id,\n        name: device.label || device.name,\n        state: isOn ? 'on' : 'off',\n        type: device.type || 'Light'\n    };\n});\n\n// Store in global\nglobal.set('hubitatLights', lightDevices);\nflow.set('lights', formattedLights);\n\n// Send to UI\nmsg.topic = 'lights';\nmsg.payload = formattedLights;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 80,
        "wires": [
            [
                "uibuilder_node"
            ]
        ]
    },
    {
        "id": "fetch_lights",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Get Lights from Flow",
        "func": "const lights = flow.get('lights') || [];\nmsg.topic = 'lights';\nmsg.payload = lights;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1240,
        "y": 320,
        "wires": [
            [
                "uibuilder_node"
            ]
        ]
    },
    {
        "id": "poll_battery",
        "type": "inject",
        "z": "uibuilder_dashboard_tab",
        "name": "Poll Battery (5s)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.5,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 140,
        "wires": [
            [
                "fetch_battery"
            ]
        ]
    },
    {
        "id": "fetch_battery",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Get Battery from Global",
        "func": "const batteryData = global.get('batteryData') || {\n    SOC: 0,\n    state: 'unknown',\n    time: new Date().toISOString()\n};\n\nmsg.topic = 'battery';\nmsg.payload = batteryData;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 380,
        "wires": [
            [
                "uibuilder_node"
            ]
        ]
    },
    {
        "id": "poll_weather",
        "type": "inject",
        "z": "uibuilder_dashboard_tab",
        "name": "Poll Weather (30s)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": 1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 200,
        "wires": [
            [
                "fetch_weather"
            ]
        ]
    },
    {
        "id": "fetch_weather",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Get Weather from Global",
        "func": "const weatherData = global.get('weather_data') || {\n    temperature: null,\n    apparent_temperature: null,\n    min_temperature: null,\n    max_temperature: null,\n    humidity: null,\n    wind_speed: null,\n    wind_direction: '',\n    cloud_description: 'No data available'\n};\n\nmsg.topic = 'weather';\nmsg.payload = weatherData;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1230,
        "y": 420,
        "wires": [
            [
                "uibuilder_node"
            ]
        ]
    },
    {
        "id": "poll_solar",
        "type": "inject",
        "z": "uibuilder_dashboard_tab",
        "name": "Poll Solar (2s)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "2",
        "crontab": "",
        "once": true,
        "onceDelay": 1.5,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 260,
        "wires": [
            [
                "fetch_solar"
            ]
        ]
    },
    {
        "id": "fetch_solar",
        "type": "function",
        "z": "uibuilder_dashboard_tab",
        "name": "Get Solar Data from Global",
        "func": "// Get power data from global context\nconst powerData = global.get('powerGraphData') || {};\nconst batteryData = global.get('batteryData') || {};\n\n// Format for solar widget\nconst solarData = {\n    systemStatus: 'online',\n    pvPower: (powerData.pv1watt || 0) / 1000,\n    batteryPower: ((powerData.p1charge1 || 0) - (powerData.pdischarge1 || 0)) / 1000,\n    batterySoc: batteryData.SOC || 0,\n    loadPower: (powerData.pactouserr || 0) / 1000,\n    gridPower: ((powerData.pactouserr || 0) - (powerData.pactogridr || 0)) / 1000,\n    priorityMode: 'Battery First'\n};\n\nmsg.topic = 'solar';\nmsg.payload = solarData;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 460,
        "wires": [
            [
                "uibuilder_node"
            ]
        ]
    }
]