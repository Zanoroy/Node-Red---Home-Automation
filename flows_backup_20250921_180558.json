[
    {
        "id": "797d03fafe67193c",
        "type": "tab",
        "label": "Solar Info",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b8e1f2c3d4a5b6c7",
        "type": "tab",
        "label": "Hubitat Dashboard",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "c9f1a2b3d4e5f6g7",
        "type": "tab",
        "label": "BOM Weather",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "d4045e31a39c5762",
        "type": "mqtt-broker",
        "name": "",
        "broker": "172.17.254.10",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "a7dcb760939c0509",
        "type": "mqtt in",
        "z": "797d03fafe67193c",
        "name": "MQTT - Energy Topic",
        "topic": "energy/growatt",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "d4045e31a39c5762",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 40,
        "wires": [
            [
                "9d504389e63c252b"
            ]
        ]
    },
    {
        "id": "9d504389e63c252b",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Battery State",
        "func": "// Extract values\nlet payload = msg.payload;\nlet SOC = payload.values.SOC;\nlet p1charge1 = payload.values.p1charge1;\nlet pdischarge1 = payload.values.pdischarge1;\n\n// Determine battery state\nlet state = \"idle\";\nif (pdischarge1 > 0) state = \"discharging\";\nelse if (p1charge1 > 0) state = \"charging\";\n\n// Output\nconst response = {\n    SOC: SOC,\n    state: state,\n    time: payload.time\n};\n\n// Store in global context for HTTP requests\nglobal.set('batteryData', response);\n\nreturn response;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 40,
        "wires": [
            []
        ]
    },
    {
        "id": "40b109e65a39f680",
        "type": "template",
        "z": "797d03fafe67193c",
        "name": "Battery Display Template",
        "field": "payload",
        "fieldType": "msg",
        "format": "html",
        "syntax": "mustache",
        "template": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n    <title>Battery Status Monitor</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n    <style>\n        /* Reset and base styles */\n        * {\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n            background: linear-gradient(135deg, #1a1a2e, #16213e);\n            color: white;\n            margin: 0;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            overflow-x: hidden;\n        }\n        \n        .battery-container {\n            text-align: center;\n            background: rgba(45, 45, 45, 0.95);\n            padding: clamp(20px, 5vw, 40px);\n            border-radius: 20px;\n            box-shadow: 0 15px 35px rgba(0,0,0,0.6);\n            backdrop-filter: blur(10px);\n            border: 1px solid rgba(255,255,255,0.1);\n            width: 100%;\n            max-width: 200px;\n        }\n        \n        .battery-wrapper {\n            position: relative;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            margin: clamp(15px, 4vw, 30px) 0;\n        }\n        \n        .battery-body {\n            position: relative;\n            width: clamp(150px, 40vw, 200px);\n            height: clamp(60px, 15vw, 80px);\n            border: clamp(3px, 1vw, 5px) solid #666;\n            border-radius: 12px;\n            background: #222;\n            overflow: hidden;\n            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        \n        .battery-terminal {\n            position: absolute;\n            right: calc(-1 * clamp(8px, 2vw, 12px));\n            top: 50%;\n            transform: translateY(-50%);\n            width: clamp(8px, 2vw, 12px);\n            height: clamp(30px, 8vw, 50px);\n            background: #666;\n            border-radius: 0 8px 8px 0;\n        }\n        \n        .battery-fill {\n            position: absolute;\n            top: 0;\n            left: 0;\n            height: 100%;\n            width: {{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}50{{/payload.SOC}}%;\n            transition: all 0.8s cubic-bezier(0.4, 0, 0.2, 1);\n            border-radius: 8px 0 0 8px;\n            background: var(--battery-color, #00ff00);\n        }\n        \n        .battery-percentage {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: clamp(18px, 5vw, 28px);\n            font-weight: 700;\n            color: white;\n            text-shadow: 2px 2px 8px rgba(0,0,0,0.9);\n            z-index: 10;\n        }\n        \n        .charging-symbol {\n            position: absolute;\n            top: clamp(8px, 2vw, 15px);\n            right: clamp(8px, 2vw, 15px);\n            font-size: clamp(16px, 4vw, 24px);\n            color: #ffff00;\n            font-weight: bold;\n            z-index: 10;\n            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);\n            display: none;\n        }\n        \n        /* State-based styling */\n        .battery-charging .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 20px rgba(0, 255, 65, 0.4);\n        }\n        \n        .battery-discharging .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 20px rgba(255, 68, 68, 0.4);\n        }\n        \n        .battery-idle .battery-body {\n            box-shadow: \n                inset 0 0 20px rgba(0,0,0,0.5),\n                0 0 15px rgba(0, 255, 65, 0.2);\n        }\n        \n        /* Animations */\n        .flash {\n            animation: flash 1.5s ease-in-out infinite;\n        }\n        \n        .flashfont {\n            animation: flashfont 1.5s ease-in-out infinite;\n        }\n        \n        @keyframes flash {\n            0%, 60% { opacity: 1; transform: scale(1); }\n            61%, 100% { opacity: 0.4; transform: scale(1.05); }\n        }\n        \n        @keyframes flashfont {\n            0%, 70% { opacity: 1; }\n            71%, 100% { opacity: 0.5; }\n        }\n        \n        /* Typography */\n        h2 {\n            margin: 0 0 clamp(20px, 5vw, 30px) 0;\n            color: #fff;\n            font-size: clamp(20px, 5vw, 28px);\n            font-weight: 600;\n        }\n        \n        .status-text {\n            font-size: clamp(16px, 4vw, 20px);\n            font-weight: 600;\n            margin: clamp(15px, 4vw, 20px) 0 clamp(8px, 2vw, 10px) 0;\n            text-transform: uppercase;\n            letter-spacing: 1px;\n        }\n        \n        .timestamp {\n            font-size: clamp(12px, 3vw, 14px);\n            color: #aaa;\n            margin-top: clamp(10px, 3vw, 15px);\n            opacity: 0.8;\n        }\n        \n        .error-message {\n            color: #ff6b6b;\n            font-size: clamp(14px, 3.5vw, 16px);\n            margin: 10px 0;\n            padding: 10px;\n            background: rgba(255, 107, 107, 0.1);\n            border-radius: 8px;\n            border: 1px solid rgba(255, 107, 107, 0.3);\n        }\n        \n        /* Responsive breakpoints */\n        @media (max-width: 480px) {\n            body { padding: 15px; }\n            .battery-container { padding: 20px 15px; }\n        }\n        \n        @media (max-width: 320px) {\n            body { padding: 10px; }\n            .battery-container { padding: 15px 10px; }\n        }\n        \n        @media (min-width: 1200px) {\n            .battery-container { max-width: 200px; }\n        }\n        \n        /* High DPI display support */\n        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {\n            .battery-body { border-width: 4px; }\n        }\n        \n        /* Reduced motion support */\n        @media (prefers-reduced-motion: reduce) {\n            .battery-fill { transition: width 0.3s ease; }\n            .flash, .flashfont { animation: none; }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"battery-container\">\n        <h2>Battery Status</h2>\n        \n        <div class=\"battery-wrapper\">\n            <div class=\"battery-body battery-{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}idle{{/payload.state}}\" id=\"batteryIcon\">\n                <div class=\"battery-fill\" id=\"batteryFill\"></div>\n                <div class=\"battery-percentage\">{{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}--{{/payload.SOC}}%</div>\n                <div class=\"charging-symbol flash\" id=\"chargingSymbol\">⚡</div>\n            </div>\n            <div class=\"battery-terminal\"></div>\n        </div>\n        \n        <div class=\"status-text\">\n            <span id=\"stateFont\">{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}Unknown{{/payload.state}}</span>\n        </div>\n        \n        <div class=\"timestamp\">\n            Last Update: <span id=\"lastUpdate\">{{#timestamp}}{{timestamp}}{{/timestamp}}{{^timestamp}}{{#payload.time}}{{payload.time}}{{/payload.time}}{{^payload.time}}Unknown{{/payload.time}}{{/timestamp}}</span>\n        </div>\n    </div>\n\n    <script>\n        // Robust error handling and data validation\n        try {\n            const state = '{{#payload.state}}{{payload.state}}{{/payload.state}}{{^payload.state}}idle{{/payload.state}}'.toLowerCase();\n            const socValue = {{#payload.SOC}}{{payload.SOC}}{{/payload.SOC}}{{^payload.SOC}}50{{/payload.SOC}};\n            \n            const chargingSymbol = document.getElementById('chargingSymbol');\n            const batteryIcon = document.getElementById('batteryIcon');\n            const stateFont = document.getElementById('stateFont');\n            const batteryFill = document.getElementById('batteryFill');\n            \n            // Validate SOC value\n            const validSOC = Math.max(0, Math.min(100, socValue || 0));\n            \n            // Set battery color based on SOC level\n            let batteryColor;\n            if (validSOC < 20) batteryColor = '#ff4444';\n            else if (validSOC < 40) batteryColor = '#ff9100';\n            else if (validSOC < 60) batteryColor = '#fff200';\n            else if (validSOC < 80) batteryColor = '#d7fc03';\n            else batteryColor = '#00ff00';\n            \n            document.documentElement.style.setProperty('--battery-color', batteryColor);\n            \n            // Handle different states\n            if (state === 'charging') {\n                stateFont.style.color = '#00ff00';\n                chargingSymbol.style.display = 'block';\n                batteryIcon.classList.add('battery-charging');\n                stateFont.classList.add('flashfont');\n            } else if (state === 'discharging') {\n                stateFont.style.color = '#ff6b6b';\n                batteryIcon.classList.add('battery-discharging');\n                stateFont.classList.add('flashfont');\n            } else {\n                stateFont.style.color = '#ffffff';\n                batteryIcon.classList.add('battery-idle');\n            }\n            \n            // Format timestamp if available\n            const lastUpdate = document.getElementById('lastUpdate');\n            const timeStr = lastUpdate.textContent;\n            if (timeStr && timeStr !== 'Unknown') {\n                try {\n                    const date = new Date(timeStr);\n                    if (!isNaN(date.getTime())) {\n                        lastUpdate.textContent = date.toLocaleString();\n                    }\n                } catch (e) {\n                    console.warn('Could not parse timestamp:', timeStr);\n                }\n            }\n            \n            // Smart refresh with exponential backoff on errors\n            let refreshAttempts = 0;\n            const maxAttempts = 5;\n            \n            function scheduleRefresh() {\n                const baseDelay = 15000; // 15 seconds base\n                const delay = refreshAttempts > 0 ? baseDelay * Math.pow(2, refreshAttempts) : baseDelay;\n                const maxDelay = 60000; // Max 1 minute\n                \n                setTimeout(() => {\n                    try {\n                        window.location.reload();\n                    } catch (e) {\n                        refreshAttempts = Math.min(refreshAttempts + 1, maxAttempts);\n                        if (refreshAttempts < maxAttempts) {\n                            scheduleRefresh();\n                        }\n                    }\n                }, Math.min(delay, maxDelay));\n            }\n            \n            scheduleRefresh();\n            \n        } catch (error) {\n            console.error('Battery display error:', error);\n            // Show error message to user\n            const container = document.querySelector('.battery-container');\n            if (container) {\n                const errorDiv = document.createElement('div');\n                errorDiv.className = 'error-message';\n                errorDiv.textContent = 'Display error: Please refresh the page';\n                container.appendChild(errorDiv);\n            }\n        }\n    </script>\n</body>\n</html>",
        "output": "str",
        "x": 770,
        "y": 140,
        "wires": [
            [
                "f7f04a3f477ab654"
            ]
        ]
    },
    {
        "id": "3d2c230142bb2983",
        "type": "http in",
        "z": "797d03fafe67193c",
        "name": "Battery Status Endpoint",
        "url": "/battery-status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 140,
        "wires": [
            [
                "466161e1adb6b7c7"
            ]
        ]
    },
    {
        "id": "466161e1adb6b7c7",
        "type": "function",
        "z": "797d03fafe67193c",
        "name": "Get Battery Data for HTTP",
        "func": "// Get the latest battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'Idle',\n    time: new Date().toISOString()\n};\nconst timestamp = batteryData.time || new Date().toISOString();\n\nmsg.payload = batteryData;\nmsg.timestamp = timestamp;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 140,
        "wires": [
            [
                "40b109e65a39f680"
            ]
        ]
    },
    {
        "id": "f7f04a3f477ab654",
        "type": "http response",
        "z": "797d03fafe67193c",
        "name": "HTTP Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "text/html"
        },
        "x": 1040,
        "y": 140,
        "wires": []
    },
    {
        "id": "h1a2b3c4d5e6f7g8",
        "type": "inject",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Fetch Devices on Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "5",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 280,
        "y": 120,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "h2a3b4c5d6e7f8g9",
        "type": "http request",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Get All Hubitat Devices",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://172.17.98.214/apps/api/93/devices/all?access_token=c978917f-7089-4041-937f-414a0bb2ab6d",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 540,
        "y": 120,
        "wires": [
            [
                "h3a4b5c6d7e8f9g0"
            ]
        ]
    },
    {
        "id": "h5a6b7c8d9e0f1g2",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Dashboard Endpoint",
        "url": "/hubitat-dashboard",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 340,
        "wires": [
            [
                "h6a7b8c9d0e1f2g3"
            ]
        ]
    },
    {
        "id": "h6a7b8c9d0e1f2g3",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Prepare Dashboard Data",
        "func": "// Get the light devices from global context\nconst lightDevices = global.get('hubitatLights') || [];\n\n// Get the battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'unknown',\n    time: new Date().toISOString()\n};\n\n// If no devices found, return empty array but still include battery\nif (lightDevices.length === 0) {\n    msg.payload = {\n        lights: [],\n        battery: batteryData,\n        timestamp: new Date().toISOString(),\n        status: 'No light devices found'\n    };\n    return msg;\n}\n\n// Process devices to get current status\nconst processedLights = lightDevices.map(device => {\n    // Determine current state based on device attributes\n    let isOn = false;\n    if (device.attributes) {\n        // Handle both array and object formats\n        if (Array.isArray(device.attributes)) {\n            const switchAttr = device.attributes.find(attr => attr.name === 'switch');\n            isOn = switchAttr && switchAttr.currentValue === 'on';\n        } else if (device.attributes.switch) {\n            isOn = device.attributes.switch === 'on';\n        }\n    }\n    \n    return {\n        id: device.id,\n        name: device.label || device.name,\n        state: isOn ? 'on' : 'off',\n        type: device.type || 'Light'\n    };\n});\n\nmsg.payload = {\n    lights: processedLights,\n    battery: batteryData,\n    timestamp: new Date().toISOString(),\n    status: 'ok'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 340,
        "wires": [
            [
                "h7a8b9c0d1e2f3g4"
            ]
        ]
    },
    {
        "id": "h7a8b9c0d1e2f3g4",
        "type": "template",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Hubitat Dashboard Template",
        "field": "payload",
        "fieldType": "msg",
        "format": "html",
        "syntax": "mustache",
        "template": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Hubitat Smart Home Dashboard</title>\n    <link rel=\"stylesheet\" href=\"/public/hubitat-dashboard.css\">\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <div class=\"endless-grid\" id=\"mainGrid\">\n            <div class=\"weather-grid\" id=\"weatherGrid\">\n                <div class=\"weather-tile\">\n\n                </div>\n            </div>\n            <div class=\"light-grid\" id=\"lightsGrid\">\n                {{#payload.lights}}\n                <div class=\"light-tile {{state}}\" data-device-id=\"{{id}}\" onclick=\"toggleLight({{id}}, '{{state}}')\">\n                    <div class=\"loading-spinner\"></div>\n                    <div class=\"light-bulb-container\">\n                        <i class=\"fas fa-lightbulb light-bulb\"></i>\n                    </div>\n                    <div class=\"light-label\">{{name}}</div>\n                </div>\n                {{/payload.lights}}\n                \n            </div>\n            <div class=\"solar-grid\" id=\"solarGrid\">\n                <!-- Battery Status Tile -->\n                <div class=\"battery-tile {{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}unknown{{/payload.battery.state}}\"\n                    id=\"batteryTile\">\n                    <div class=\"battery-wrapper\">\n                        <div class=\"battery-body\">\n                            <div class=\"battery-fill\" id=\"batteryFill\"></div>\n                            <div class=\"battery-percentage\">\n                                {{#payload.battery.SOC}}{{payload.battery.SOC}}{{/payload.battery.SOC}}{{^payload.battery.SOC}}--{{/payload.battery.SOC}}%\n                            </div>\n                            <div class=\"charging-symbol\" id=\"chargingSymbol\">⚡</div>\n                        </div>\n                        <div class=\"battery-terminal\"></div>\n                    </div>\n                    <div class=\"status-text\">\n                        <span id=\"stateFont\" style=\"color: #ffffff;\">{{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}Idle{{/payload.battery.state}}</span>\n                    </div>\n                    <div class=\"battery-label\">Battery Status</div>\n                </div>\n                <div>&nbsp;</div>\n            </div>\n            <div class=\"status-bar\">\n                <span id=\"statusText\" class=\"status-online\">Connected</span> | \n                Last Update: <span id=\"lastUpdate\">{{payload.timestamp}}</span>\n            </div>\n        </div>\n    </div>\n    <script>\n        let isPolling = true;\n        \n        // Format timestamp\n        function formatTimestamp(timestamp) {\n            return new Date(timestamp).toLocaleString();\n        }\n        \n        // Update last update timestamp\n        document.getElementById('lastUpdate').textContent = formatTimestamp('{{payload.timestamp}}');\n        \n        // Initialize battery display\n        initializeBattery();\n        \n        function initializeBattery() {\n            try {\n                const batteryData = {\n                    state: '{{#payload.battery.state}}{{payload.battery.state}}{{/payload.battery.state}}{{^payload.battery.state}}unknown{{/payload.battery.state}}',\n                    SOC: {{#payload.battery.SOC}}{{payload.battery.SOC}}{{/payload.battery.SOC}}{{^payload.battery.SOC}}0{{/payload.battery.SOC}}\n                };\n                \n                const chargingSymbol = document.getElementById('chargingSymbol');\n                const batteryTile = document.getElementById('batteryTile');\n                const batteryFill = document.getElementById('batteryFill');\n                const stateFont = document.getElementById('stateFont');\n\n                // Validate SOC value\n                const validSOC = Math.max(0, Math.min(100, batteryData.SOC || 0));\n                \n                // Set battery fill width\n                batteryFill.style.width = validSOC + '%';\n                \n                // Set battery color based on SOC level\n                let batteryColor;\n                if (validSOC < 20) batteryColor = '#ff4444';\n                else if (validSOC < 40) batteryColor = '#ff9100';\n                else if (validSOC < 60) batteryColor = '#fff200';\n                else if (validSOC < 80) batteryColor = '#d7fc03';\n                else batteryColor = '#00ff00';\n                \n                batteryFill.style.background = batteryColor;\n                \n                // Handle charging state\n                if (batteryData.state.toLowerCase() === 'charging') {\n                    chargingSymbol.style.display = 'block';\n                    chargingSymbol.classList.add('flash');\n                    batteryTile.classList.add('battery-charging');\n                    stateFont.style.color = '#00ff00';\n                    stateFont.classList.remove('flashfont');\n                    stateFont.innerHTML = \"charging\";\n                } else {\n                    chargingSymbol.style.display = 'none';\n                    chargingSymbol.classList.remove('flash');\n                    if (batteryData.state.toLowerCase() === 'discharging') {\n                        batteryTile.classList.add('battery-discharging');\n                        stateFont.style.color = '#ff6b6b';\n                        stateFont.classList.add('flashfont');\n                        stateFont.innerHTML = \"discharging\";\n                    } else {\n                        batteryTile.classList.add('battery-idle');\n                        stateFont.style.color = '#ffffff';\n                        stateFont.classList.remove('flashfont');\n                        stateFont.innerHTML = \"idle\";\n                    }\n                }\n            } catch (error) {\n                console.warn('Battery initialization error:', error);\n            }\n        }\n        \n        // Toggle light function\n        async function toggleLight(deviceId, currentState) {\n            const tile = document.querySelector(`[data-device-id=\"${deviceId}\"]`);\n            const newState = currentState === 'on' ? 'off' : 'on';\n            \n            // Add loading state\n            tile.classList.add('loading');\n            \n            try {\n                const response = await fetch(`/hubitat-control/${deviceId}/${newState}`, {\n                    method: 'POST'\n                });\n                \n                if (response.ok) {\n                    // Update tile state immediately for better UX\n                    tile.classList.remove('on', 'off', 'error');\n                    tile.classList.add(newState);\n                    tile.setAttribute('onclick', `toggleLight(${deviceId}, '${newState}')`);\n                } else {\n                    throw new Error('Failed to control device');\n                }\n            } catch (error) {\n                console.error('Error controlling light:', error);\n                tile.classList.add('error');\n                setTimeout(() => tile.classList.remove('error'), 3000);\n            } finally {\n                tile.classList.remove('loading');\n            }\n        }\n        \n        // Refresh dashboard data\n        async function refreshDashboard() {\n            try {\n                const response = await fetch('/hubitat-status');\n                if (response.ok) {\n                    const data = await response.json();\n                    updateDashboard(data);\n                    updateBattery(data.battery);\n                    document.getElementById('statusText').textContent = 'Connected';\n                    document.getElementById('statusText').className = 'status-online';\n                } else {\n                    throw new Error('Failed to fetch status');\n                }\n            } catch (error) {\n                console.error('Error refreshing dashboard:', error);\n                document.getElementById('statusText').textContent = 'Offline';\n                document.getElementById('statusText').className = 'status-offline';\n            }\n        }\n        \n        // Update dashboard with new data\n        function updateDashboard(data) {\n            data.lights.forEach(light => {\n                const tile = document.querySelector(`[data-device-id=\"${light.id}\"]`);\n                if (tile) {\n                    tile.classList.remove('on', 'off', 'error');\n                    tile.classList.add(light.state);\n                    tile.setAttribute('onclick', `toggleLight(${light.id}, '${light.state}')`);\n                }\n            });\n            \n            document.getElementById('lastUpdate').textContent = formatTimestamp(data.timestamp);\n        }\n        \n        // Update battery display\n        function updateBattery(batteryData) {\n            if (!batteryData) return;\n            \n            try {\n                const chargingSymbol = document.getElementById('chargingSymbol');\n                const batteryTile = document.getElementById('batteryTile');\n                const batteryFill = document.getElementById('batteryFill');\n                const batteryPercentage = batteryTile.querySelector('.battery-percentage');\n                const stateFont = document.getElementById('stateFont');\n                \n                // Update percentage text\n                if (batteryPercentage) {\n                    batteryPercentage.textContent = (batteryData.SOC || 0) + '%';\n                }\n                \n                // Validate SOC value\n                const validSOC = Math.max(0, Math.min(100, batteryData.SOC || 0));\n                \n                // Set battery fill width\n                batteryFill.style.width = validSOC + '%';\n                \n                // Set battery color based on SOC level\n                let batteryColor;\n                if (validSOC < 20) batteryColor = '#ff4444';\n                else if (validSOC < 40) batteryColor = '#ff9100';\n                else if (validSOC < 60) batteryColor = '#fff200';\n                else if (validSOC < 80) batteryColor = '#d7fc03';\n                else batteryColor = '#00ff00';\n                \n                batteryFill.style.background = batteryColor;\n                \n                // Clear previous state classes\n                batteryTile.classList.remove('battery-charging', 'battery-discharging', 'battery-idle');\n\n                // Handle charging state\n                if (batteryData.state && batteryData.state.toLowerCase() === 'charging') {\n                    stateFont.style.color = '#00ff00';\n                    stateFont.classList.remove('flashfont');\n                    chargingSymbol.style.display = 'block';\n                    chargingSymbol.classList.add('flash');\n                    batteryTile.classList.add('battery-charging');\n                    stateFont.innerHTML = \"charging\";\n                } else {\n                    chargingSymbol.style.display = 'none';\n                    chargingSymbol.classList.remove('flash');\n                    if (batteryData.state && batteryData.state.toLowerCase() === 'discharging') {\n                        batteryTile.classList.add('battery-discharging');\n                        stateFont.style.color = '#ff6b6b';\n                        stateFont.classList.add('flashfont');\n                        stateFont.innerHTML = \"discharging\";\n                    } else {\n                        batteryTile.classList.add('battery-idle');\n                        stateFont.style.color = '#ffffff';\n                        stateFont.classList.remove('flashfont');\n                        stateFont.innerHTML = \"idle\";\n                    }\n                }\n            } catch (error) {\n                console.warn('Battery update error:', error);\n            }\n        }\n        \n        // Start polling for updates every 10 seconds\n        if (isPolling) {\n            setInterval(refreshDashboard, 10000);\n        }\n        \n        // Add keyboard navigation\n        document.addEventListener('keydown', function(event) {\n            if (event.key === 'r' || event.key === 'R') {\n                refreshDashboard();\n            }\n        });\n        \n        console.log('Hubitat Dashboard loaded with {{payload.lights.length}} lights');\n    </script>\n</body>\n</html>",
        "output": "str",
        "x": 770,
        "y": 340,
        "wires": [
            [
                "h8a9b0c1d2e3f4g5"
            ]
        ]
    },
    {
        "id": "h8a9b0c1d2e3f4g5",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Dashboard Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "text/html"
        },
        "x": 1070,
        "y": 340,
        "wires": []
    },
    {
        "id": "h9a0b1c2d3e4f5g6",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Device Control Endpoint",
        "url": "/hubitat-control/:deviceId/:command",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 240,
        "wires": [
            [
                "h0a1b2c3d4e5f6g7"
            ]
        ]
    },
    {
        "id": "h0a1b2c3d4e5f6g7",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Prepare Control Command",
        "func": "// Extract device ID and command from URL parameters\nconst deviceId = msg.req.params.deviceId;\nconst command = msg.req.params.command;\n\n// Validate command\nif (command !== 'on' && command !== 'off') {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Invalid command. Use on or off.' };\n    return msg;\n}\n\n// Validate device ID\nif (!deviceId || isNaN(parseInt(deviceId))) {\n    msg.statusCode = 400;\n    msg.payload = { error: 'Invalid device ID.' };\n    return msg;\n}\n\n// Prepare the Hubitat API URL\nconst baseUrl = 'http://172.17.98.214/apps/api/93/devices';\nconst accessToken = 'c978917f-7089-4041-937f-414a0bb2ab6d';\nconst url = `${baseUrl}/${deviceId}/${command}?access_token=${accessToken}`;\n\nmsg.url = url;\nmsg.method = 'GET';\nmsg.deviceId = deviceId;\nmsg.command = command;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 240,
        "wires": [
            [
                "h1a2b3c4d5e6f7g8_control"
            ]
        ]
    },
    {
        "id": "h1a2b3c4d5e6f7g8_control",
        "type": "http request",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Send Control to Hubitat",
        "method": "use",
        "ret": "txt",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 790,
        "y": 240,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9_response"
            ]
        ]
    },
    {
        "id": "h2a3b4c5d6e7f8g9_response",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Format Control Response",
        "func": "// Prepare response\nconst response = {\n    success: true,\n    deviceId: msg.deviceId,\n    command: msg.command,\n    timestamp: new Date().toISOString(),\n    hubitatResponse: msg.payload\n};\n\nmsg.payload = response;\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 240,
        "wires": [
            [
                "h3a4b5c6d7e8f9g0_response",
                "cccde8f277d49879"
            ]
        ]
    },
    {
        "id": "h3a4b5c6d7e8f9g0_response",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Control Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 1690,
        "y": 240,
        "wires": []
    },
    {
        "id": "h4a5b6c7d8e9f0g1_status",
        "type": "http in",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Status API Endpoint",
        "url": "/hubitat-status",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 210,
        "y": 420,
        "wires": [
            [
                "h5a6b7c8d9e0f1g2_status"
            ]
        ]
    },
    {
        "id": "h5a6b7c8d9e0f1g2_status",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Get Current Status",
        "func": "// Get the light devices from global context\nconst lightDevices = global.get('hubitatLights') || [];\n\n// Get the battery data from global context\nconst batteryData = global.get('batteryData') || {\n    SOC: 50,\n    state: 'unknown',\n    time: new Date().toISOString()\n};\n\n// Process devices to get current status\nconst processedLights = lightDevices.map(device => {\n    // Determine current state based on device attributes\n    let isOn = false;\n    if (device.attributes) {\n        // Handle both array and object formats\n        if (Array.isArray(device.attributes)) {\n            const switchAttr = device.attributes.find(attr => attr.name === 'switch');\n            isOn = switchAttr && switchAttr.currentValue === 'on';\n        } else if (device.attributes.switch) {\n            isOn = device.attributes.switch === 'on';\n        }\n    }\n    \n    return {\n        id: device.id,\n        name: device.label || device.name,\n        state: isOn ? 'on' : 'off',\n        type: device.type || 'Light'\n    };\n});\n\nmsg.payload = {\n    lights: processedLights,\n    battery: batteryData,\n    timestamp: new Date().toISOString(),\n    status: 'ok'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 420,
        "wires": [
            [
                "h6a7b8c9d0e1f2g3_status"
            ]
        ]
    },
    {
        "id": "h6a7b8c9d0e1f2g3_status",
        "type": "http response",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Status Response",
        "statusCode": "",
        "headers": {
            "Content-Type": "application/json"
        },
        "x": 750,
        "y": 420,
        "wires": []
    },
    {
        "id": "h3a4b5c6d7e8f9g0",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Filter Light Devices",
        "func": "// Target light device IDs\nconst targetIds = [17, 1, 2, 3, 4, 20, 5];\n\n// Filter devices to only include our target lights\nconst allDevices = msg.payload;\nconst lightDevices = allDevices.filter(device => targetIds.includes(parseInt(device.id)));\n\n// Store filtered devices in global context\nglobal.set('hubitatLights', lightDevices);\n\n// Return the filtered devices\nmsg.payload = lightDevices;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 120,
        "wires": [
            [
                "h4a5b6c7d8e9f0g1"
            ]
        ]
    },
    {
        "id": "h4a5b6c7d8e9f0g1",
        "type": "debug",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Light Devices Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 120,
        "wires": []
    },
    {
        "id": "cccde8f277d49879",
        "type": "function",
        "z": "b8e1f2c3d4a5b6c7",
        "name": "Trigger status update.",
        "func": "// Prepare response\nmsg.payload = new Date().getTime(); // returns milliseconds\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1320,
        "y": 200,
        "wires": [
            [
                "h2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "w1a2b3c4d5e6f7g8",
        "type": "inject",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Fetch Weather Every 10 Min",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 80,
        "wires": [
            [
                "w2a3b4c5d6e7f8g9"
            ]
        ]
    },
    {
        "id": "w2a3b4c5d6e7f8g9",
        "type": "exec",
        "z": "c9f1a2b3d4e5f6g7",
        "command": "curl",
        "addpay": "payload",
        "append": "-s ftp://ftp.bom.gov.au/anon/gen/fwo/IDS60920.xml",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Get BOM Weather Data",
        "x": 510,
        "y": 80,
        "wires": [
            [
                "w3a4b5c6d7e8f9g0",
                "1ae4e02bfeeb028b"
            ],
            [],
            []
        ]
    },
    {
        "id": "w3a4b5c6d7e8f9g0",
        "type": "xml",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Parse XML",
        "property": "payload",
        "attr": "attr",
        "chr": "",
        "x": 890,
        "y": 80,
        "wires": [
            [
                "w4a5b6c7d8e9f0g1"
            ]
        ]
    },
    {
        "id": "w4a5b6c7d8e9f0g1",
        "type": "function",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Extract Weather Data",
        "func": "// Extract weather data for Adelaide area stations with enhanced debugging\nconst weatherData = {};\nconst stations = [];\n\ntry {\n    // Debug: Log the structure we received\n    node.warn('Received payload structure: ' + JSON.stringify(Object.keys(msg.payload), null, 2));\n    \n    // Handle different possible XML structures\n    let observations;\n    if (msg.payload.product && msg.payload.product.observations) {\n        observations = msg.payload.product.observations;\n    } else if (msg.payload.observations) {\n        observations = msg.payload.observations;\n    } else {\n        node.warn('Cannot find observations in payload');\n        throw new Error('No observations found in XML structure');\n    }\n    \n    node.warn('Found observations: ' + JSON.stringify(Object.keys(observations), null, 2));\n    \n    // Check if observations is an array and get the first element\n    if (Array.isArray(observations) && observations.length > 0) {\n        observations = observations[0];\n        node.warn('Using first observations array element');\n    } else if (observations['0']) {\n        // Sometimes XML parser creates indexed objects instead of arrays\n        observations = observations['0'];\n        node.warn('Using indexed observations element');\n    }\n    \n    node.warn('Observations structure after processing: ' + JSON.stringify(Object.keys(observations), null, 2));\n    \n    if (observations && observations.station) {\n        const stationArray = Array.isArray(observations.station) ? observations.station : [observations.station];\n        node.warn(`Processing ${stationArray.length} stations`);\n        \n        // Look for stations near Banksia Park\n        const targetStations = ['PARAFIELD', 'ADELAIDE AIRPORT', 'ADELAIDE (WEST TERRACE', 'WEST TERRACE'];\n        \n        stationArray.forEach((station, index) => {\n            try {\n                // Handle both attribute structures: station.$ or station.attr\n                const attrs = station.$ || station.attr || station;\n                const stationName = attrs['stn-name'] || attrs.stnName || 'Unknown';\n                \n                node.warn(`Station ${index}: ${stationName}`);\n                \n                // Check if this is a station we want\n                const isTargetStation = targetStations.some(target => \n                    stationName.toUpperCase().includes(target.toUpperCase())\n                );\n                \n                if (isTargetStation) {\n                    node.warn(`Processing target station: ${stationName}`);\n                    \n                    // Get the most recent period (usually index 0)\n                    const period = Array.isArray(station.period) ? station.period[0] : station.period;\n                    if (!period) {\n                        node.warn('No period data found for station: ' + stationName);\n                        return;\n                    }\n                    \n                    // Get surface level data\n                    const level = Array.isArray(period.level) ? period.level[0] : period.level;\n                    if (!level) {\n                        node.warn('No level data found for station: ' + stationName);\n                        return;\n                    }\n                    \n                    // Initialize station data\n                    const stationData = {\n                        station_name: stationName,\n                        station_id: attrs['bom-id'] || attrs.bomId || 'unknown',\n                        latitude: parseFloat(attrs['lat'] || attrs.latitude || 0),\n                        longitude: parseFloat(attrs['lon'] || attrs.longitude || 0),\n                        timestamp: (period.$ || period.attr || period)['time-utc'] || new Date().toISOString(),\n                        local_time: (period.$ || period.attr || period)['time-local'] || new Date().toLocaleString()\n                    };\n                    \n                    // Process elements\n                    if (level.element) {\n                        const elements = Array.isArray(level.element) ? level.element : [level.element];\n                        node.warn(`Found ${elements.length} elements for ${stationName}`);\n                        \n                        elements.forEach(element => {\n                            const elementAttrs = element.$ || element.attr || element;\n                            const type = elementAttrs.type || elementAttrs['type'];\n                            const value = element._ || element.value || element;\n                            const units = elementAttrs.units || elementAttrs['units'];\n                            \n                            if (type && value !== undefined && value !== null) {\n                                switch(type) {\n                                    case 'air_temperature':\n                                        stationData.temperature = parseFloat(value);\n                                        stationData.temperature_units = units;\n                                        break;\n                                    case 'apparent_temp':\n                                        stationData.apparent_temperature = parseFloat(value);\n                                        break;\n                                    case 'dew_point':\n                                        stationData.dew_point = parseFloat(value);\n                                        break;\n                                    case 'rel-humidity':\n                                        stationData.humidity = parseFloat(value);\n                                        stationData.humidity_units = units;\n                                        break;\n                                    case 'wind_spd_kmh':\n                                        stationData.wind_speed = parseFloat(value);\n                                        stationData.wind_speed_units = units;\n                                        break;\n                                    case 'wind_dir':\n                                        stationData.wind_direction = value;\n                                        break;\n                                    case 'wind_dir_deg':\n                                        stationData.wind_direction_degrees = parseFloat(value);\n                                        break;\n                                    case 'gust_kmh':\n                                        stationData.wind_gust = parseFloat(value);\n                                        break;\n                                    case 'msl_pres':\n                                        stationData.pressure = parseFloat(value);\n                                        stationData.pressure_units = units;\n                                        break;\n                                    case 'rainfall':\n                                        const duration = elementAttrs.duration || elementAttrs['duration'];\n                                        stationData.rainfall_since_9am = parseFloat(value);\n                                        break;\n                                    case 'rainfall_24hr':\n                                        stationData.rainfall_24hr = parseFloat(value);\n                                        break;\n                                    case 'vis_km':\n                                        stationData.visibility = parseFloat(value);\n                                        stationData.visibility_units = units;\n                                        break;\n                                    case 'cloud':\n                                        stationData.cloud_description = value;\n                                        break;\n                                    case 'cloud_oktas':\n                                        stationData.cloud_oktas = parseFloat(value);\n                                        break;\n                                    case 'minimum_air_temperature':\n                                        stationData.min_temperature = parseFloat(value);\n                                        break;\n                                    case 'maximum_air_temperature':\n                                        stationData.max_temperature = parseFloat(value);\n                                        break;\n                                }\n                            }\n                        });\n                    }\n                    \n                    stations.push(stationData);\n                    node.warn(`Added station data for: ${stationName}`);\n                }\n            } catch (stationError) {\n                node.warn(`Error processing station ${index}: ${stationError.message}`);\n            }\n        });\n    }\n    \n    node.warn(`Total stations processed: ${stations.length}`);\n    \n    // Find the best station (prefer Parafield, then Adelaide Airport)\n    let selectedStation = null;\n    \n    for (const station of stations) {\n        if (station.station_name.toUpperCase().includes('PARAFIELD')) {\n            selectedStation = station;\n            break;\n        }\n    }\n    \n    if (!selectedStation) {\n        for (const station of stations) {\n            if (station.station_name.toUpperCase().includes('ADELAIDE AIRPORT')) {\n                selectedStation = station;\n                break;\n            }\n        }\n    }\n    \n    if (!selectedStation && stations.length > 0) {\n        selectedStation = stations[0];\n    }\n    \n    if (selectedStation) {\n        // Prepare final weather data\n        weatherData.temperature = selectedStation.temperature || null;\n        weatherData.apparent_temperature = selectedStation.apparent_temperature || null;\n        weatherData.min_temperature = selectedStation.min_temperature || null;\n        weatherData.max_temperature = selectedStation.max_temperature || null;\n        weatherData.humidity = selectedStation.humidity || null;\n        weatherData.pressure = selectedStation.pressure || null;\n        weatherData.wind_speed = selectedStation.wind_speed || null;\n        weatherData.wind_direction = selectedStation.wind_direction || null;\n        weatherData.wind_gust = selectedStation.wind_gust || null;\n        weatherData.rainfall_24hr = selectedStation.rainfall_24hr || 0;\n        weatherData.rainfall_since_9am = selectedStation.rainfall_since_9am || 0;\n        weatherData.visibility = selectedStation.visibility || null;\n        weatherData.cloud_description = selectedStation.cloud_description || null;\n        weatherData.dew_point = selectedStation.dew_point || null;\n        weatherData.station_name = selectedStation.station_name;\n        weatherData.timestamp = selectedStation.timestamp;\n        weatherData.local_time = selectedStation.local_time;\n        weatherData.latitude = selectedStation.latitude;\n        weatherData.longitude = selectedStation.longitude;\n        weatherData.last_updated = new Date().toISOString();\n        \n        // Store in global context\n        global.set('weather_data', weatherData);\n        \n        msg.payload = weatherData;\n        node.status({fill:\"green\",shape:\"dot\",text:`Updated: ${selectedStation.station_name.substring(0, 20)}`});\n        node.warn('Weather data successfully processed and stored');\n        \n        return msg;\n    } else {\n        node.status({fill:\"red\",shape:\"ring\",text:\"No target stations found\"});\n        node.warn('No target stations found in the data');\n        return null;\n    }\n    \n} catch (error) {\n    node.error('Weather parsing error: ' + error.message);\n    node.warn('Full error: ' + JSON.stringify(error, null, 2));\n    node.status({fill:\"red\",shape:\"ring\",text:`Error: ${error.message.substring(0, 20)}`});\n    return null;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 80,
        "wires": [
            [
                "w5a6b7c8d9e0f1g2",
                "w6a7b8c9d0e1f2g3"
            ]
        ]
    },
    {
        "id": "w5a6b7c8d9e0f1g2",
        "type": "mqtt out",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Publish Weather to MQTT",
        "topic": "weather/current",
        "qos": "0",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d4045e31a39c5762",
        "x": 1390,
        "y": 60,
        "wires": []
    },
    {
        "id": "w6a7b8c9d0e1f2g3",
        "type": "debug",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Weather Debug",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1370,
        "y": 120,
        "wires": []
    },
    {
        "id": "w7a8b9c0d1e2f3g4",
        "type": "http in",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Weather API Endpoint",
        "url": "/weather",
        "method": "get",
        "upload": false,
        "swaggerDoc": "",
        "x": 130,
        "y": 360,
        "wires": [
            [
                "w8a9b0c1d2e3f4g5"
            ]
        ]
    },
    {
        "id": "w8a9b0c1d2e3f4g5",
        "type": "function",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Get Current Weather",
        "func": "// Get weather data from global context\nconst weatherData = global.get('weather_data') || {};\n\nif (Object.keys(weatherData).length === 0) {\n    msg.payload = {\n        error: 'No weather data available',\n        message: 'Weather data is being fetched. Please try again in a few minutes.'\n    };\n    msg.statusCode = 503;\n} else {\n    msg.payload = weatherData;\n    msg.statusCode = 200;\n}\n\nmsg.headers = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*'\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 360,
        "wires": [
            [
                "w9a0b1c2d3e4f5g6"
            ]
        ]
    },
    {
        "id": "w9a0b1c2d3e4f5g6",
        "type": "http response",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "Weather Response",
        "statusCode": "",
        "headers": {},
        "x": 630,
        "y": 360,
        "wires": []
    },
    {
        "id": "1ae4e02bfeeb028b",
        "type": "debug",
        "z": "c9f1a2b3d4e5f6g7",
        "name": "weather data debg",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 920,
        "y": 140,
        "wires": []
    }
]